<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://zxpzhong.github.io/</id>
    <title>Felix计算机视觉小屋</title>
    <updated>2020-04-05T02:01:58.730Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://zxpzhong.github.io/"/>
    <link rel="self" href="https://zxpzhong.github.io/atom.xml"/>
    <subtitle>念念不忘必有回响：&lt;a href=&quot;https://github.com/zxpzhong&quot; target=&quot;_blank&quot;&gt;我的github&lt;/a&gt;;&lt;a href=&quot;http://aicv.club/&quot; target=&quot;_blank&quot;&gt;我的博客&lt;/a&gt;</subtitle>
    <logo>https://zxpzhong.github.io/images/avatar.png</logo>
    <icon>https://zxpzhong.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Felix计算机视觉小屋</rights>
    <entry>
        <title type="html"><![CDATA[基于指静脉的身份识别系统（横向项目，已落地）]]></title>
        <id>https://zxpzhong.github.io/post/ji-yu-zhi-jing-mai-de-shen-fen-shi-bie-xi-tong-heng-xiang-xiang-mu-yi-luo-di/</id>
        <link href="https://zxpzhong.github.io/post/ji-yu-zhi-jing-mai-de-shen-fen-shi-bie-xi-tong-heng-xiang-xiang-mu-yi-luo-di/">
        </link>
        <updated>2020-04-05T02:00:00.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://zxpzhong.github.io//post-images/1586052016336.jpg" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Multi-Source Transfer for Finger Vein Recognition]]></title>
        <id>https://zxpzhong.github.io/post/multi-source-transfer-for-finger-vein-recognition/</id>
        <link href="https://zxpzhong.github.io/post/multi-source-transfer-for-finger-vein-recognition/">
        </link>
        <updated>2020-04-05T01:58:08.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://zxpzhong.github.io//post-images/1586051947568.jpg" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[腾讯笔试题汇总]]></title>
        <id>https://zxpzhong.github.io/post/腾讯笔试题汇总/</id>
        <link href="https://zxpzhong.github.io/post/腾讯笔试题汇总/">
        </link>
        <updated>2020-03-22T16:04:41.000Z</updated>
        <summary type="html"><![CDATA[<p>腾讯笔试题汇总</p>
]]></summary>
        <content type="html"><![CDATA[<p>腾讯笔试题汇总</p>
<!-- more -->
<h1 id="写在前面">写在前面</h1>
<p>其实这个只是一个简单的汇总而已，不论是哪家厂，算法方法就那些，只要leetcode、剑指多刷一刷，哪家厂都没问题！！！</p>
<p>文中所有的题目都来自于牛客网及acwing！！！</p>
<h1 id="腾讯16年研发笔试题评测地址">腾讯16年研发笔试题(<a href="https://www.nowcoder.com/test/710813/summary">评测地址</a>)</h1>
<h2 id="编程题生成格雷码">[编程题]生成格雷码</h2>
<h3 id="题目">题目</h3>
<p>在一组数的编码中，若任意两个相邻的代码只有一位二进制数不同， 则称这种编码为格雷码(Gray Code)，请编写一个函数，使用递归的方法生成N位的格雷码。给定一个整数<strong>n</strong>，请返回n位的格雷码，顺序为从0开始。</p>
<p>测试样例：</p>
<pre><code class="language-python">1
返回：[&quot;0&quot;,&quot;1&quot;]
</code></pre>
<h3 id="解答">解答</h3>
<p>格雷码是一种经典的位操作（Bit Manipulation）题目，格雷码的生成方法有两种（<mark>必背</mark>）：</p>
<ol>
<li>按位数生成序列：已知两位的格雷码为：<code>00 01 11 10</code>,从三位的格雷码开始，先在二位的格雷码<strong>前</strong>添加0得到：<code>000 001 011 010</code>，再添加<code>1</code>并且调换两个的顺序得到：<code>110 111 101 100</code>，拼接后得到三位格雷码为：<code>000 001 011 010 110 111 101 100</code>，以此类推可以得到四位，五位。。。</li>
<li>（推荐）直接生成第n位格雷码：<code>Gray(n) = n XOR n/2</code></li>
</ol>
<p>通过第一种或者第二种都可以生成格雷码，题目中要求我们返回N位的格雷码，因此采用第一种方法。</p>
<pre><code class="language-python">class GrayCode:
    def getGray(self, n):
        # 定义初始1位格雷码
        base = ['0','1']
        for i in range(n-1):
            add_0 = []
            add_1 = []
            # 左侧补0
            for item in base:
                add_0.append('0'+item)
            # 左侧补1
            for item in base:
                add_1.append('1'+item)
            # 颠倒
            add_1 = add_1[::-1]
            base = add_0+add_1
        return base
</code></pre>
<h2 id="编程题微信红包">[编程题]微信红包</h2>
<h3 id="题目-2">题目</h3>
<p>春节期间小明使用微信收到很多个红包，非常开心。在查看领取红包记录时发现，某个红包金额出现的次数超过了红包总数的一半。请帮小明找到该红包金额。写出具体算法思路和代码实现，要求算法尽可能高效。</p>
<p>给定一个红包的金额数组<strong>gifts</strong>及它的大小<strong>n</strong>，请返回所求红包的金额。</p>
<p>若没有金额超过总数的一半，返回0。</p>
<p>测试样例：</p>
<pre><code>[1,2,3,2,2],5
返回：2
</code></pre>
<h3 id="解答-2">解答</h3>
<p>题中要求找到某个金额出现次数超过红包总数的一半（其实就是最大出现次数超过一半，因为超过一半一定是最大出现次数），返回该金额值。由于需要找到超过次数，需要对前面所有出现过的红包金额进行计数，单次遍历所有红包复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，为某金额的计数器累加，这里很明显应该采用<mark>哈希编码</mark>，使得每次查找金额计数器的复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，为了方便直接使用python内置的<code>collections.Counter</code>模块（当然可以自己构建，但是解题思想应该就是哈希）。</p>
<pre><code class="language-python">from collections import Counter
class Gift:
    def getValue(self, gifts, n):
        a = Counter(gifts)
        if max(a.values()) &gt; n/2:
       			# 根据值返回键
            return  list (a.keys()) [list (a.values()).index (max(a.values()))]
        else:
            return 0
</code></pre>
<h1 id="腾讯17年秋招笔试题评测地址">腾讯17年秋招笔试题(<a href="https://www.nowcoder.com/test/5582994/summary">评测地址</a>)</h1>
<h2 id="编程题编码">[编程题]编码</h2>
<h3 id="题目-3">题目</h3>
<p>假定一种编码的编码范围是a ~ y的25个字母，从1位到4位的编码，如果我们把该编码按字典序排序，形成一个数组如下： a, aa, aaa, aaaa, aaab, aaac, … …, b, ba, baa, baaa, baab, baac … …, yyyw, yyyx, yyyy 其中a的Index为0，aa的Index为1，aaa的Index为2，以此类推。 编写一个函数，输入是任意一个编码，输出这个编码对应的Index.</p>
<p><strong>输入描述</strong>：输入一个待编码的字符串,字符串长度小于等于100.</p>
<p><strong>输出描述</strong>：输出这个编码的index</p>
<p><strong>输入例子1</strong>：<code>baca</code></p>
<p><strong>输出例子1</strong>：<code>16331</code></p>
<h3 id="解答-3">解答</h3>
<p>按照题意，该编码的值范围为<code>0~(25^4-1)</code>，而且编码顺序按字典序排序。对于四位编码<code>****</code>的第一位，以<code>a</code>开头的包含<code>25^0+25^1+25^2+25^3</code>个编码，则以<code>a</code>开头的编码index在<code>0~25^0+25^1+25^2+25^3</code>之间，以b开头的编码index在<code>0+a的范围~a的范围+25^0+25^1+25^2+25^3</code>之间，依次类推。同样的对于三位编码<code>***</code>的第一位，以<code>a</code>开头的包含<code>25^0+25^1+25^2</code>个编码。对于二位编码<code>**</code>的第一位，以<code>a</code>开头的包含``25<sup>0+25</sup>1`个编码，最后对于一位编码以a开头的只有1中（就是a本身）。因此可以采用按序号顺序诸位求范围的方法。</p>
<pre><code class="language-python">import sys
s = sys.stdin.readline().strip()
length = len(s)
candi = ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y']
ans = 0
for i in range(length):
    temp = [25**j for j in range(4-i)]
    base = sum(temp)
    ans+=candi.index(s[i]) * base
print(ans+length-1)
</code></pre>
<h2 id="编程题游戏任务标记">[编程题]游戏任务标记</h2>
<h3 id="题目-4">题目</h3>
<p>游戏里面有很多各式各样的任务，其中有一种任务玩家只能做一次，这类任务一共有1024个，任务ID范围[1,1024]。请用32个unsigned int类型来记录着1024个任务是否已经完成。初始状态都是未完成。 输入两个参数，都是任务ID，需要设置第一个ID的任务为已经完成；并检查第二个ID的任务是否已经完成。 输出一个参数，如果第二个ID的任务已经完成输出1，如果未完成输出0。如果第一或第二个ID不在[1,1024]范围，则输出-1。</p>
<p><strong>输入描述</strong>：输入包括一行,两个整数表示人物ID.</p>
<p><strong>输出描述</strong>：输出是否完成</p>
<p><strong>输入例子1</strong>：1024 1024</p>
<p><strong>输出例子1</strong>：1</p>
<h3 id="解答-4">解答</h3>
<p>初始状态都是未完成，设置一个ID完成，检查第二个ID是否完成，如果不加思考的话，直接一句话就可以做完。</p>
<pre><code class="language-python">import sys
t1, t2 = list(map(int, sys.stdin.readline().strip().split()))
if not 1 &lt;= t1 &lt;= 1024 or not 1 &lt;= t2 &lt;= 1024:
    print(-1)
elif t1 == t2:
    print(1)
else:
    print(0)
</code></pre>
<p>但是如果任务数目特别大且初始状态不一定为未完成，就不能简单直接判断返回了。对于大数某一位的快速置位复位可以采用位运算：</p>
<ul>
<li>对a的第b位置位：a+1&lt;&lt;b</li>
<li>对a的第b位复位：a and ~(1&lt;&lt;b)</li>
<li>取出a的第b位：a&amp;(1&lt;&lt;b)</li>
</ul>
<pre><code class="language-python">import sys
t1, t2 = list(map(int, sys.stdin.readline().strip().split()))
task = [0] * 32
if t1 in range(1, 1025) and t2 in range(1, 1025):
    index1 = int((t1-1)/32)
    index2 = (t1-1)%32
    if not task[index1] &amp; (1&lt;&lt;index2): 
        task[index1] = task[index1] + 1&lt;&lt;index2
    index1 = int((t2-1)/32)
    index2 = (t2-1)%32
    if task[index1]&amp;(1&lt;&lt;index2):
        print(1)
    else:
        print(0)
else:
    print(-1)
</code></pre>
<h2 id="编程题素数对">[编程题]素数对</h2>
<h3 id="题目-5">题目</h3>
<p>给定一个正整数，编写程序计算有多少对质数的和等于输入的这个正整数，并输出结果。输入值小于1000。<br>
如，输入为10, 程序应该输出结果为2。（共有两对质数的和为10,分别为(5,5),(3,7)）</p>
<p><strong>输入描述</strong>：输入包括一个整数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo separator="true">,</mo><mo>(</mo><mn>3</mn><mo>≤</mo><mi>n</mi><mo>&lt;</mo><mn>1000</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">n,(3 ≤ n &lt; 1000)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mclose">)</span></span></span></span></p>
<p><strong>输出描述</strong>：输出对数</p>
<p><strong>输入例子1</strong>：10</p>
<p><strong>输出例子1</strong>：2</p>
<h3 id="解答-5">解答</h3>
<p>直接遍历可以AC，质数的出现也没有规律，只能挨个判断</p>
<pre><code class="language-python">import sys
n = list(map(int,sys.stdin.readline().strip().split()))[0]
def isOK(num):
    # 判断是否为质数
    for i in range(2,num):
        if num%i == 0:
            return False
    return True
ans = 0
for i in range(2,n//2 + 1):
    if isOK(i) and isOK(n-i):
        ans +=1
        # print(i,'OK')
    else:
        pass
        # print(i,'not OK')
print(ans)
</code></pre>
<h2 id="编程题geohash编码">[编程题]geohash编码</h2>
<h3 id="题目-6">题目</h3>
<p>geohash编码：geohash常用于将二维的经纬度转换为字符串，分为两步：第一步是经纬度的二进制编码，第二步是base32转码。<br>
此题考察纬度的二进制编码：算法对纬度[-90, 90]通过二分法进行无限逼近（取决于所需精度，本题精度为6）。注意，本题进行二分法逼近过程中只采用向下取整来进行二分，针对二分中间值属于右区间。算法举例如下： 针对纬度为80进行二进制编码过程：</p>
<ol>
<li>区间[-90, 90]进行二分为[-90, 0),[0, 90]，成为左右区间，可以确定80为右区间，标记为1；</li>
<li>针对上一步的右区间[0, 90]进行二分为[0, 45),[45, 90]，可以确定80是右区间，标记为1；</li>
<li>针对[45, 90]进行二分为[45, 67),[67,90],可以确定80为右区间，标记为1；</li>
<li>针对[67,90]进行二分为[67, 78),[78,90]，可以确定80为右区间，标记为1；</li>
<li>针对[78, 90]进行二分为[78, 84),[84, 90]，可以确定80为左区间，标记为0；</li>
<li>针对[78, 84)进行二分为[78, 81), [81, 84)，可以确定80为左区间，标记为0；</li>
</ol>
<p><strong>输入描述</strong>：输入包括一个整数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo separator="true">,</mo><mo>(</mo><mo>−</mo><mn>90</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>90</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">n,(-90 ≤ n ≤ 90)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord">−</span><span class="mord">9</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">9</span><span class="mord">0</span><span class="mclose">)</span></span></span></span></p>
<p><strong>输出描述</strong>：输出二进制编码</p>
<p><strong>输入例子1</strong>：80</p>
<p><strong>输出例子1</strong>：111100</p>
<h3 id="解答-6">解答</h3>
<p>跟二分法的思想一样不断二分即可，到达指定层级，本题精度为6，直接返回即可</p>
<pre><code class="language-python">import sys
n = list(map(int,sys.stdin.readline().strip().split()))[0]
left = -90
right = 90
middle = int((left+right)/2)
ans = ''
for i in range(6):
    # print(middle)
    # 本题的精度为6
    if n &lt; middle:
        ans+='0'
        right = middle
    elif n &gt;= middle:
        ans+='1'
        left = middle
    # 更新边界和中值
    middle = int((left+right)/2)
print(ans)
</code></pre>
<h1 id="腾讯18年春招笔试题评测地址">腾讯18年春招笔试题(<a href="https://www.nowcoder.com/test/10611931/summary">评测地址</a>)</h1>
<h2 id="编程题翻转数列">[编程题]翻转数列</h2>
<h3 id="题目-7">题目</h3>
<p>小Q定义了一种数列称为翻转数列:<br>
给定整数n和m, 满足n能被2m整除。对于一串连续递增整数数列1, 2, 3, 4..., 每隔m个符号翻转一次, 最初符号为'-';。<br>
例如n = 8, m = 2, 数列就是: -1, -2, +3, +4, -5, -6, +7, +8.<br>
而n = 4, m = 1, 数列就是: -1, +2, -3, + 4.<br>
小Q现在希望你能帮他算算前n项和为多少。</p>
<p><strong>输入描述</strong>：输入包括两个整数n和m(2 &lt;= n &lt;= 109, 1 &lt;= m), 并且满足n能被2m整除。</p>
<p><strong>输出描述</strong>：输出一个整数, 表示前n项和。</p>
<p><strong>输入例子1</strong>：8 2</p>
<p><strong>输出例子1</strong>：8</p>
<h3 id="解答-7">解答</h3>
<p>送分题，<code>2m</code>个数为一组，一共<code>n/2m</code>组，每组和为<code>m*m</code>，和为<code>m*n/2</code></p>
<pre><code class="language-python">import sys
n,m = list(map(int,sys.stdin.readline().strip().split()))
print(int(n*m/2))
</code></pre>
<h2 id="编程题纸牌游戏">[编程题]纸牌游戏</h2>
<h3 id="题目-8">题目</h3>
<p>牛牛和羊羊正在玩一个纸牌游戏。这个游戏一共有n张纸牌, 第i张纸牌上写着数字ai。<br>
牛牛和羊羊轮流抽牌, 牛牛先抽, 每次抽牌他们可以从纸牌堆中任意选择一张抽出, 直到纸牌被抽完。<br>
他们的得分等于他们抽到的纸牌数字总和。<br>
现在假设牛牛和羊羊都采用最优策略, 请你计算出游戏结束后牛牛得分减去羊羊得分等于多少。</p>
<p><strong>输入描述</strong>：</p>
<pre><code>输入包括两行。
第一行包括一个正整数n(1 &lt;= n &lt;= 105),表示纸牌的数量。
第二行包括n个正整数ai(1 &lt;= ai &lt;= 109),表示每张纸牌上的数字。
</code></pre>
<p><strong>输出描述</strong>：输出一个整数, 表示游戏结束后牛牛得分减去羊羊得分等于多少。</p>
<p><strong>输入例子1</strong>：</p>
<pre><code>3
2 7 4
</code></pre>
<p><strong>输出例子1</strong>：5</p>
<h3 id="解答-8">解答</h3>
<p>送分题，降序排序后，直接奇数项-偶数项和</p>
<pre><code class="language-python">import sys
n = list(map(int,sys.stdin.readline().strip().split()))[0]
a = list(map(int,sys.stdin.readline().strip().split()))
a.sort()
a = a[::-1]
print(sum(a[::2])-sum(a[1::2]))
</code></pre>
<h2 id="编程题贪吃的小q">[编程题]贪吃的小Q</h2>
<h3 id="题目-9">题目</h3>
<p>小Q的父母要出差N天，走之前给小Q留下了M块巧克力。小Q决定每天吃的巧克力数量不少于前一天吃的一半，但是他又不想在父母回来之前的某一天没有巧克力吃，请问他第一天最多能吃多少块巧克力</p>
<p><strong>输入描述</strong>：</p>
<pre><code>每个输入包含一个测试用例。
每个测试用例的第一行包含两个正整数，表示父母出差的天数N(N&lt;=50000)和巧克力的数量M(N&lt;=M&lt;=100000)。
</code></pre>
<p><strong>输出描述</strong>：输出一个数表示小Q第一天最多能吃多少块巧克力。</p>
<p><strong>输入例子1</strong>：3 7</p>
<p><strong>输出例子1</strong>：4</p>
<h3 id="解答非最优解">解答【非最优解】</h3>
<p>如果解除”一半“的限制，小Q第一天能吃的最多的巧克力为M-N+1，最少能吃的块数为1块，在``1~M-N+1`之间找到最大的块数。可以采用二分查找，找出最大的满足”一半“限制的巧克力块数。这种方法还是暴力解法，只不过套了一个二分查找，外层复杂度由O(n)降为O(logn)，但是对于每个第一天，还是要计算所有天数的巧克力块数，因此应该不是最优解，但是也能AC。</p>
<pre><code class="language-python">import sys 
N,M = list(map(int,sys.stdin.readline().strip().split()))
def isOK(first):
    # 吃掉的计数器
    eat_all = 0
    # 当天可以吃掉的最多
    max_day = first
    for i in range(N):
        eat_all+=max_day
        max_day = max_day//2 + (1 if max_day%2 else 0)
    if eat_all &lt;= M:
        return True
    else:
        return False
# 二分法，类似二分排序
# 第一天吃的
min_first = 1
max_first = M
max_ = 0
first = 0
while max_first-min_first &gt;1:
    # 取二分中点
    first = (max_first+min_first)//2
    if isOK(first):
        # 吃得掉
        max_ = max(max_,first)
        min_first = first
    else:
        # 吃不掉
        max_first = first
if isOK(max_+1):
    print(max_+1)
else:
    print(max_)
</code></pre>
<h2 id="编程题小q的歌单">[编程题]小Q的歌单</h2>
<h3 id="题目-10">题目</h3>
<p>小Q有X首长度为A的不同的歌和Y首长度为B的不同的歌，现在小Q想用这些歌组成一个总长度正好为K的歌单，每首歌最多只能在歌单中出现一次，在不考虑歌单内歌曲的先后顺序的情况下，请问有多少种组成歌单的方法。</p>
<p><strong>输入描述</strong>：</p>
<pre><code>每个输入包含一个测试用例。
每个测试用例的第一行包含一个整数，表示歌单的总长度K(1&lt;=K&lt;=1000)。
接下来的一行包含四个正整数，分别表示歌的第一种长度A(A&lt;=10)和数量X(X&lt;=100)以及歌的第二种长度B(B&lt;=10)和数量Y(Y&lt;=100)。保证A不等于B。
</code></pre>
<p><strong>输出描述</strong>：输出一个整数,表示组成歌单的方法取模。因为答案可能会很大,输出对1000000007取模的结果。</p>
<p><strong>输入例子1</strong>：</p>
<pre><code>5
2 3 3 3
</code></pre>
<p><strong>输出例子1</strong>：9</p>
<h3 id="解答-9">解答</h3>
<p><mark>略</mark></p>
<h2 id="编程题安排机器">[编程题]安排机器</h2>
<h3 id="题目-11">题目</h3>
<p>小Q的公司最近接到m个任务, 第i个任务需要xi的时间去完成, 难度等级为yi。<br>
小Q拥有n台机器, 每台机器最长工作时间zi, 机器等级wi。<br>
对于一个任务,它只能交由一台机器来完成, 如果安排给它的机器的最长工作时间小于任务需要的时间, 则不能完成,如果完成这个任务将获得200 * xi + 3 * yi收益。</p>
<p>对于一台机器,它一天只能完成一个任务, 如果它的机器等级小于安排给它的任务难度等级, 则不能完成。</p>
<p>小Q想在今天尽可能的去完成任务, 即完成的任务数量最大。如果有多种安排方案,小Q还想找到收益最大的那个方案。小Q需要你来帮助他计算一下。</p>
<p><strong>输入描述</strong>：</p>
<pre><code>输入包括N + M + 1行,
输入的第一行为两个正整数n和m(1 &lt;= n, m &lt;= 100000), 表示机器的数量和任务的数量。
接下来n行,每行两个整数zi和wi(0 &lt; zi &lt; 1000, 0 &lt;= wi &lt;= 100), 表示每台机器的最大工作时间和机器等级。
接下来的m行,每行两个整数xi和yi(0 &lt; xi &lt; 1000, 0 &lt;= yi&lt;= 100), 表示每个任务需要的完成时间和任务的难度等级。
</code></pre>
<p><strong>输出描述</strong>：输出两个整数, 分别表示最大能完成的任务数量和获取的收益。</p>
<p><strong>输入例子1</strong>：</p>
<pre><code>1 2
100 3
100 2
100 1
</code></pre>
<p><strong>输出例子1</strong>：1 20006</p>
<h3 id="解答-10">解答</h3>
<p><mark>略</mark></p>
<h2 id="编程题画家小q">[编程题]画家小Q</h2>
<h3 id="题目-12">题目</h3>
<p>画家小Q又开始他的艺术创作。小Q拿出了一块有NxM像素格的画板, 画板初始状态是空白的,用'X'表示。<br>
小Q有他独特的绘画技巧,每次小Q会选择一条斜线, 如果斜线的方向形如'/',即斜率为1,小Q会选择这条斜线中的一段格子,都涂画为蓝色,用'B'表示;如果对角线的方向形如'',即斜率为-1,小Q会选择这条斜线中的一段格子,都涂画为黄色,用'Y'表示。<br>
如果一个格子既被蓝色涂画过又被黄色涂画过,那么这个格子就会变成绿色,用'G'表示。小Q已经有想画出的作品的样子, 请你帮他计算一下他最少需要多少次操作完成这幅画。</p>
<p><strong>输入描述</strong>：</p>
<pre><code>每个输入包含一个测试用例。
每个测试用例的第一行包含两个正整数N和M(1 &lt;= N, M &lt;= 50), 表示画板的长宽。
接下来的N行包含N个长度为M的字符串, 其中包含字符'B','Y','G','X',分别表示蓝色,黄色,绿色,空白。整个表示小Q要完成的作品。
</code></pre>
<p><strong>输出描述</strong>：输出一个正整数, 表示小Q最少需要多少次操作完成绘画。</p>
<p><strong>输入例子1</strong>：</p>
<pre><code>4 4
YXXB
XYGX
XBYY
BXXY
</code></pre>
<p><strong>输出例子1</strong>：3</p>
<p><strong>例子说明1</strong>：</p>
<pre><code>XXXX
XXXX
XXXX
XXXX
-&gt;
YXXX
XYXX
XXYX
XXXY
-&gt;
YXXB
XYBX
XBYX
BXXY
-&gt;
YXXB
XYGX
XBYY
BXXY
</code></pre>
<h3 id="解答-11">解答</h3>
<p><mark>略</mark></p>
<h1 id="腾讯19年暑期实习笔试题">腾讯19年暑期实习笔试题</h1>
<h2 id="编程题01串评测地址">[编程题]01串(<a href="https://www.acwing.com/problem/content/604/">评测地址</a>)</h2>
<h3 id="题目-13">题目</h3>
<p>给定一个仅包含0或1的字符串，现在可以对其进行一种操作：当有两个相邻的字符其中有一个是0另外一个是1的时候，可以消除掉这两个字符。这样的操作可以一直进行下去直到找不到相邻的0和1为止。问这个字符串经历了操作以后的最短长度。</p>
<p><strong>输入描述</strong>：</p>
<pre><code>第一行包含一个整数 n，表示字符串的初始长度。
第二行为所给字符串。
</code></pre>
<p><strong>输出描述</strong>：输出共一行，包含一个整数，表示问题的解。</p>
<p><strong>数据范围</strong>：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>2</mn><mi mathvariant="normal">∗</mi><mn>105</mn></mrow><annotation encoding="application/x-tex">1≤n≤2∗105</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">∗</span><span class="mord">1</span><span class="mord">0</span><span class="mord">5</span></span></span></span></p>
<p><strong>输入例子1</strong>：</p>
<pre><code>4
1100
</code></pre>
<p><strong>输出例子1</strong>：0</p>
<p><strong>输入例子2</strong>：</p>
<pre><code>5
01010
</code></pre>
<p><strong>输出例子2</strong>：1</p>
<h3 id="解答-12">解答</h3>
<p>输入例子1中，<code>1100</code>中间两个0和1相邻消去后为<code>10</code>，可以再次消去剩余0字符。由此分析，某个<mark>仅包含01</mark>的字符串中，如果0和1都存在，则一定存在0和1相邻可以消去，由此得最终剩余的字符串仅包含0或者1，也就是原始字符串中<code>abs(0的个数-1的个数)</code>。</p>
<pre><code class="language-python">import sys
n = list(map(int,sys.stdin.readline().strip().split()))[0]
s = sys.stdin.readline().strip()
from collections import Counter
temp = Counter(s)
print(abs(temp['1']-temp['0']))
</code></pre>
<h2 id="编程题硬币评测地址">[编程题]硬币(<a href="https://www.acwing.com/problem/content/569/">评测地址</a>)</h2>
<h3 id="题目-14">题目</h3>
<p>牛家村的货币是一种很神奇的连续货币。他们货币的最大面额是n，并且一共有面额为1，面额为2.....面额为n，n种面额的货币。牛牛每次购买商品都会带上所有面额的货币，支付时会选择给出硬币数量最小的方案。</p>
<p>现在告诉你牛牛将要购买的商品的价格，你能算出牛牛支付的硬币数量吗？ (假设牛牛每种面额的货币都拥有无限个。)</p>
<p><strong>输入描述</strong>：</p>
<pre><code>共一行，包含两个整数n和m，分别表示货币的最大面额以及商品的价格。
</code></pre>
<p><strong>输出描述</strong>：一个整数表示牛牛支付的硬币数量。</p>
<p><strong>数据范围</strong>：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>105</mn><mo separator="true">,</mo><mn>1</mn><mo>≤</mo><mi>m</mi><mo>≤</mo><mn>109</mn></mrow><annotation encoding="application/x-tex">1≤n≤105,1≤m≤109</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">9</span></span></span></span></p>
<p><strong>输入例子1</strong>：</p>
<pre><code>6 7
</code></pre>
<p><strong>输出例子1</strong>：2</p>
<p><strong>输入例子2</strong>：</p>
<pre><code>4 10
</code></pre>
<p><strong>输出例子2</strong>：3</p>
<h3 id="解答-13">解答</h3>
<p>🐂🐂有1,2,....,n的所有面额的货币，且数量不限。要拼出总价为m的商品价格。典型的贪心算法，按面额大小依次取走最大数量的硬币数量即可。比如输入例子1中，7元不存在，6元存在取走7//6=1个，剩余1元，当剩余面额小于或等于n时，直接取走对应的剩余面额即可，所以答案是两个。</p>
<pre><code class="language-python">import sys
n,m = list(map(int,sys.stdin.readline().strip().split()))
ans = m//n
print(ans if m%n == 0 else ans+1)
</code></pre>
<h2 id="编程题奇妙的数列评测地址">[编程题]奇妙的数列(<a href="https://www.acwing.com/problem/content/570/">评测地址</a>)</h2>
<h3 id="题目-15">题目</h3>
<p>妞妞最近迷上了王者荣耀。</p>
<p>小Q得到了一个奇妙的数列，这个数列有无限多项，数列中的第 i 个数字为i∗(−1)ii∗(−1)i，比如数列的前几项为-1，2，-3，4，-5…</p>
<p>小Q兴奋把这个数列拿去给妞妞看，并希望借此邀请妞妞吃饭。</p>
<p>妞妞想了想，对小Q说：“对于这个数列，我每次询问你一个区间，你在1秒内把这个区间里的数字的和告诉我，如果你答得上来我就跟你一起去吃饭。”</p>
<p>由于妞妞最近沉迷王者荣耀，已经很久都没理过小Q了，所以小Q不想失去这次珍贵的机会，你能帮帮他吗？</p>
<p><strong>输入描述</strong>：</p>
<pre><code>第一行，一个整数 q，表示妞妞的询问次数。
接下来 q 行，每行两个整数 l 和 r，表示妞妞询问的区间的左端点和右端点。
</code></pre>
<p><strong>输出描述</strong>：共 q 行，每行一个整数，表示妞妞询问的区间和。</p>
<p><strong>数据范围</strong>：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>q</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup><mo separator="true">,</mo><mn>1</mn><mo>≤</mo><mi>l</mi><mo>≤</mo><mi>r</mi><mo>≤</mo><mn>109</mn></mrow><annotation encoding="application/x-tex">1≤q≤10^5,1≤l≤r≤109</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8304100000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.008548em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83041em;vertical-align:-0.13597em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">9</span></span></span></span></p>
<p><strong>输入例子1</strong>：</p>
<pre><code>4
2 4
2 2
3 3
1 5
</code></pre>
<p><strong>输出例子1</strong>：</p>
<pre><code>3
2
-3
-3
</code></pre>
<p><strong>输入例子2</strong>：</p>
<pre><code>1
1 1000000000
</code></pre>
<p><strong>输出例子2</strong>：</p>
<pre><code>500000000
</code></pre>
<h3 id="解答-14">解答</h3>
<p>对于给定的区间端点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mo>=</mo><mn>2</mn><mo separator="true">,</mo><mi>r</mi><mo>=</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">l=2,r=5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span></span></span></span>，区间内所有的数为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mo separator="true">,</mo><mo>−</mo><mn>3</mn><mo separator="true">,</mo><mn>4</mn><mo separator="true">,</mo><mo>−</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">2,-3,4,-5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">−</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">−</span><span class="mord">5</span></span></span></span>,可以看到从首项开始，每两项的和为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mo>−</mo><mn>1</mn><msup><mo>)</mo><mo>(</mo></msup><mn>1</mn><mi>i</mi><mi>f</mi><mi>l</mi><mi mathvariant="normal">%</mi><mn>2</mn><mo>=</mo><mo>=</mo><mn>1</mn><mi>e</mi><mi>l</mi><mi>s</mi><mi>e</mi><mo>−</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">(-1)^(1    ifl\%2 == 1 else -1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.138em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">−</span><span class="mord">1</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mopen mtight">(</span></span></span></span></span></span></span></span><span class="mord">1</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord">%</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>,这样的对数为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>r</mi><mo>−</mo><mi>l</mi><mo>+</mo><mn>1</mn><mo>)</mo><mi mathvariant="normal">/</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">(r-l+1)//2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">/</span><span class="mord">/</span><span class="mord">2</span></span></span></span>，当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>r</mi><mo>−</mo><mi>l</mi><mo>+</mo><mn>1</mn><mo>)</mo><mi mathvariant="normal">%</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">(r-l+1)\%2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">%</span><span class="mord">2</span></span></span></span>为1时，还会剩余最后一项，最后一项的大小为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mo>∗</mo><mo>(</mo><mn>1</mn><mi>i</mi><mi>f</mi><mi>r</mi><mi mathvariant="normal">%</mi><mn>2</mn><mo>=</mo><mo>=</mo><mn>0</mn><mi>e</mi><mi>l</mi><mi>s</mi><mi>e</mi><mo>−</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">r*(1 if r\%2 == 0 else -1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord">%</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。</p>
<pre><code class="language-python">import sys
texts = []
q = sys.stdin.readline().strip()
for line in sys.stdin:
    if not line:
        break
    l,r = list(map(int,line.strip().split()))
    temp1 = (r-l+1)//2*(1 if l%2 == 1 else -1)
    temp2 = (r*(1 if r%2 == 0 else -1) if (r-l+1) % 2 == 1 else 0)
    ans = temp1 + temp2
    print(ans)
</code></pre>
<h2 id="编程题气球游戏评测地址">[编程题]气球游戏(<a href="https://www.acwing.com/problem/content/572/">评测地址</a>)</h2>
<h3 id="题目-16">题目</h3>
<p>小Q在进行射击气球的游戏，如果小Q在连续T枪中打爆了所有颜色的气球，将得到一只QQ公仔作为奖励。（每种颜色的球至少被打爆一只）。</p>
<p>这个游戏中有m种不同颜色的气球，编号1到m。</p>
<p>小Q一共有n发子弹，然后连续开了n枪。</p>
<p>小Q想知道在这n枪中，打爆所有颜色的气球最少用了连续几枪？</p>
<p><strong>输入格式</strong>：第一行包含两个整数n和m。第二行包含n个整数，分别表示每一枪打中的气球的颜色，0表示没打中任何颜色的气球。</p>
<p><strong>输出格式</strong>：一个整数表示小Q打爆所有颜色气球用的最少枪数。如果小Q无法在这n枪打爆所有颜色的气球，则输出-1。</p>
<p><strong>数据范围</strong>：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>106</mn><mo separator="true">,</mo><mn>1</mn><mo>≤</mo><mi>m</mi><mo>≤</mo><mn>2000</mn></mrow><annotation encoding="application/x-tex">1≤n≤106,1≤m≤2000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></p>
<p><strong>输入样例：</strong></p>
<pre><code>12 5
2 5 3 1 3 2 4 1 0 5 4 3
</code></pre>
<p><strong>输出样例：</strong></p>
<pre><code>6
</code></pre>
<p><strong>样例解释</strong></p>
<p>有五种颜色的气球，编号1到5。</p>
<p>游客从第二枪开始直到第七枪，这连续六枪打爆了5 3 1 3 2 4这几种颜色的气球，包含了从1到5的所有颜色，所以最少枪数为6。</p>
<h3 id="解答-15">解答</h3>
<p>题目要求我们在给出的序列中找到最短的包含所有气球的子列。要特别注意空枪带来的影响。</p>
<ul>
<li>暴力解法：对于每个元素都遍历，以这个元素开头的剩余序列的最短子列，复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。</li>
<li>双指针：设置左指针和右指针，分别指向目标区间的左端点和右端点，
<ol>
<li>首先保持左端点不动，移动右指针，直到找到最小的包含所有气球的子列</li>
<li>找到包含所有气球的子列后，固定右指针，向右移动左指针，收缩区间长度，直到到达符合条件的最小区间长度</li>
<li>循环前两步</li>
</ol>
</li>
</ul>
<pre><code class="language-python">import sys 
text = []
n,m = list(map(int,sys.stdin.readline().strip().split()))
candidate = list(map(int,sys.stdin.readline().strip().split()))
dp = [0 for _ in range(m)]
# 双指针：对于每一个右指针，找到最小的左指针范围
pt1 = 0
pt2 = 0
min_len = 1000001
while pt1 &lt; n:
    # 如果有空的，则pt2一直往下，直到找到dp中包含全部的
    if 0 in dp:
        if pt2 == n:
            break
        elif not candidate[pt2] == 0:
            dp[candidate[pt2]-1]+=1
        pt2+=1
    else:
        if not candidate[pt1] == 0:
        # 如果没有空的，那么对于当前的pt2找到最小pt1
            min_len = min(min_len,pt2-pt1)
            dp[candidate[pt1]-1]-=1
        pt1+=1
if min_len == 1000001:
    print(-1)
else:
    print(min_len)
</code></pre>
<h2 id="编程题猜拳游戏评测地址">[编程题]猜拳游戏(<a href="https://www.acwing.com/problem/content/571/">评测地址</a>)</h2>
<h3 id="题目-17">题目</h3>
<p>小Q和牛妹参加一个剪刀石头布的游戏，游戏用卡片来玩，每张卡片是剪刀，石头，布中的一种，每种类型的卡片有无限个。</p>
<p>牛妹从中选了n张卡片排成一排，正面朝下，小Q也会选择n张卡片排成一排，然后小Q和牛妹的卡片会依次进行比对，第一张对第一张，第二张对第二张…</p>
<p>如果小Q赢，小Q会得到一分，现在已知牛妹的每一张牌以及小Q最终的得分 s，请问小Q有多少种选择卡片的方案(多少不同的排列)</p>
<p><strong>输入格式</strong>：</p>
<pre><code class="language-第一行包含两个整数">第二行包含 n 个整数，表示牛妹的每张卡片，每个数在[0,2]之间，0代表石头，1代表布，2代表剪刀。
</code></pre>
<p><strong>输出格式</strong>：</p>
<pre><code>输出一个整数，表示总方案数对10^9+7取模后的值。
</code></pre>
<p><strong>数据范围</strong>：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>2000</mn><mo separator="true">,</mo><mn>0</mn><mo>≤</mo><mi>s</mi><mo>≤</mo><mn>2000</mn></mrow><annotation encoding="application/x-tex">1≤n≤2000,0≤s≤2000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></p>
<p><strong>输入样例</strong>：</p>
<pre><code>3 2
0 1 2
</code></pre>
<p><strong>输出样例</strong>：</p>
<pre><code>6
</code></pre>
<h3 id="解答-16">解答</h3>
<p>牛妹的最终得分为s分，所以n张卡片中选出s张得分，每张得分的只有一种选择，不得分的有2中选择，因此卡片的方案一共有：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>C</mi><mi>n</mi><mi>s</mi></msubsup><mo>∗</mo><msup><mn>2</mn><mrow><mi>n</mi><mo>−</mo><mi>s</mi></mrow></msup></mrow><annotation encoding="application/x-tex">C_{n}^{s}*2^{n-s}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9613919999999999em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7143919999999999em;"><span style="top:-2.4530000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.821331em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.821331em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">s</span></span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>代码如下：</p>
<pre><code class="language-python">n,s = list(map(int , input() .split()))
nums = list(map(int , input(). split()))
import math
print(((math.factorial(n)/(math.factorial(s)*math.factorial(n-s)))*(2**(n-s)))%(10**9+7))
</code></pre>
<p>但是上面的代码并<mark>不能AC</mark>，在数特别大时会出错。我们知道：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>C</mi><mi>n</mi><mi>s</mi></msubsup><mo>=</mo><mfrac><mrow><mi>n</mi><mo>!</mo></mrow><mrow><mi>s</mi><mo>!</mo><mo>∗</mo><mo>(</mo><mi>n</mi><mo>−</mo><mi>s</mi><mo>)</mo><mo>!</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">C_{n}^{s}=\frac{n!}{s!*(n-s)!}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.93033em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-2.4530000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.400108em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span><span class="mclose mtight">!</span><span class="mbin mtight">∗</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">s</span><span class="mclose mtight">)</span><span class="mclose mtight">!</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mclose mtight">!</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>,是一定可以整除的，所以在写除法的时候，可能会直接用除，但是：</p>
<pre><code class="language-python">factorial(40) / factorial(15) = 5.873182941643167e+18
factorial(40) // factorial(15) = 623943776229081622823099695104000000
</code></pre>
<p>正确答案为（<mark>除号变为整除</mark>），这个问题在阿里2020实习面试中也出现了，大家不要再中招了！！：</p>
<pre><code class="language-python">n,s = list(map(int , input() .split()))
nums = list(map(int , input(). split()))
import math
print(((math.factorial(n)//(math.factorial(s)*math.factorial(n-s)))*(2**(n-s)))%(10**9+7))
</code></pre>
<h2 id="编程题小q购物评测地址">[编程题]小Q购物(<a href="https://www.acwing.com/problem/content/603/">评测地址</a>)</h2>
<h3 id="题目-18">题目</h3>
<p>小Q去商场购物，经常会遇到找零的问题。</p>
<p>小Q现在手上有n种不同面值的硬币，每种面值的硬币都有无限多个。</p>
<p>为了方便购物，小Q希望带尽量少的硬币，并且要能组合出1到m之间（包含1和m）的所有面值。</p>
<p><strong>输入格式</strong>：</p>
<pre><code>第一行包含两个整数m和n。
接下来n行，每行一个整数，第 i+1 行的整数表示第 i 种硬币的面值。
</code></pre>
<p><strong>输出格式</strong>：</p>
<pre><code>输出一个整数，表示最少需要携带的硬币数量。
如果无解，则输出-1。
</code></pre>
<p><strong>数据范围</strong>：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>100</mn><mo separator="true">,</mo><mn>1</mn><mo>≤</mo><mi>m</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup><mi mathvariant="normal">，</mi><mn>1</mn><mo>≤</mo><mi mathvariant="normal">硬</mi><mi mathvariant="normal">币</mi><mi mathvariant="normal">面</mi><mi mathvariant="normal">值</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">1≤n≤100,1≤m≤10^9，1≤硬币面值≤10^9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.950078em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span><span class="mord cjk_fallback">，</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord cjk_fallback">硬</span><span class="mord cjk_fallback">币</span><span class="mord cjk_fallback">面</span><span class="mord cjk_fallback">值</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span></p>
<p><strong>输入样例：</strong></p>
<pre><code>20 4
1
2
5
10
</code></pre>
<p><strong>输出样例：</strong></p>
<pre><code>5
</code></pre>
<h3 id="解答-17">解答</h3>
<p>给定的输入样例中，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mo>=</mo><mn>20</mn><mo separator="true">,</mo><mi>n</mi><mo>=</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">m=20,n=4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span>，也就是我们要利用<code>1,2,5,10</code>四种硬币凑出<code>1,2,...,20</code>一共20种面值。</p>
<p>我们来模拟凑硬币的过程：</p>
<ol>
<li>
<p>首先我们一定会拿走1，如果没有1，那么一定无法凑齐1。所有如果给定的硬币无1，直接返回-1</p>
</li>
<li>
<p>拿走1后，我们要凑2。凑2有两种选择：</p>
<ul>
<li>再拿走一枚一元的</li>
<li>拿走一枚两元的</li>
</ul>
<p>这里我们应该拿走一枚两元的，因为拿走一元的和两元的，你的硬币数目都为2，但是后者的面值范围却比前者大。</p>
</li>
<li>
<p>我们已经拿了<code>1枚1元、1枚2元</code>，硬币范围为1~3，接下来要凑4元。和上面类似，我们可以拿走一元的和两元，我们会选择面试更大的2元，此时面值范围为：1-5元</p>
</li>
<li>
<p>由上面三步分析，我们在凑往下一个数时，总是拿最大的面额，类似于贪心法则</p>
</li>
<li>
<p>第四步分析中，我们总是拿最大的面额，当我们到达5/10/20时，最大面额更新，直接取走相应的最大面额即可（即我们要凑5元，直接拿走5元，凑10元，直接拿走10元）。因此我们的目标更新为：<mark>利用已有的最大面额硬币，凑出下一个最大面额硬币-1元</mark>（即2元时，我们要凑出1元，5元时我们要凑出4元，10元时我们要凑出9元）。</p>
</li>
</ol>
<p>根据上面的分析，假设到达硬币面额为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">S[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>，下一个硬币面额为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mo>[</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">S[i+1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>，当前余额为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>，我们在余额<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>的基础上，需要<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span></span></span></span>枚<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">S[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>，来凑出至少<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mo>[</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo>]</mo><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">S[i+1]-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>元。即<code>m+K*S[i] &gt;= S[i+1]-1</code>，因此可以得到我们需要面额为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">S[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>的硬币数目为：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>K</mi><mo>≥</mo><mfrac><mrow><mo>(</mo><mi>S</mi><mo>[</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo>]</mo><mo>−</mo><mn>1</mn><mo>)</mo><mo>−</mo><mi>m</mi></mrow><mrow><mi>S</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">K\geq \frac{(S[i+1]-1)-m}{S[i]}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.363em;vertical-align:-0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<pre><code class="language-python">import sys
import math
m,n = list(map(int,sys.stdin.readline().strip().split()))
money = []
for line in sys.stdin:
    money.append(int(line.strip().split()[0]))
if not money[0] == 1:
    print(-1)
    exit()
money.sort()
# money中大于的去除
for i in range(len(money)):
    if money[i] &gt; m:
        break
money = money[:i+1]
# 最后要凑m-1，所以在最后添加一枚虚拟硬币，这样处理起来代码简单
money.append(m+1)
# 当前余额
S = 1
count = 1
for i in range(len(money)-1):
    # 要凑money[i+1]-1元
    temp = math.ceil((money[i+1]-1-S)/money[i])
    S+= temp * money[i]
    count += temp
print(count)
</code></pre>
<h1 id="腾讯20年校园招聘笔试题评测地址">腾讯20年校园招聘笔试题(<a href="https://www.nowcoder.com/test/21283868/summary">评测地址</a>)</h1>
<h2 id="编程题压缩算法">[编程题]压缩算法</h2>
<h3 id="题目-19">题目</h3>
<p>小Q想要给他的朋友发送一个神秘字符串，但是他发现字符串的过于长了，于是小Q发明了一种压缩算法对字符串中重复的部分进行了压缩，对于字符串中连续的m个相同字符串S将会压缩为[m|S] (m为一个整数且1&lt;=m&lt;=100)，例如字符串ABCABCABC将会被压缩为[3|ABC]，现在小Q的同学收到了小Q发送过来的字符串，你能帮助他进行解压缩么？</p>
<p><strong>输入描述:</strong></p>
<pre><code>输入第一行包含一个字符串s，代表压缩后的字符串。
S的长度&lt;=1000;
S仅包含大写字母、[、]、|;
解压后的字符串长度不超过100000;
压缩递归层数不超过10层;
</code></pre>
<p><strong>输出描述:</strong></p>
<pre><code>输出一个字符串，代表解压后的字符串。
</code></pre>
<p><strong>输入例子1:</strong></p>
<pre><code>HG[3|B[2|CA]]F
</code></pre>
<p><strong>输出例子1:</strong></p>
<pre><code>HGBCACABCACABCACAF
</code></pre>
<p><strong>例子说明1:</strong></p>
<pre><code>HG[3|B[2|CA]]F−&gt;HG[3|BCACA]F−&gt;HGBCACABCACABCACAF
</code></pre>
<h3 id="解答-18">解答</h3>
<p>类似于判断<code>() []</code>是否合法，一层一层找到最内层<code>[]</code>然后依次解码即可。为了在O(n)的复杂度内完成，每次遇到'['是入栈，遇到']'时出栈并解码，并更新指针位置，字符串长度。</p>
<pre><code class="language-python">import sys 
s = sys.stdin.readline().strip()
stack = []
# 由内到外拆解
i = 0
length = len(s)
while i &lt; length:
    if s[i] == '[':
        stack.append(i)
    if s[i] == ']':
        if i == len(s):
            break
        pt1 = stack.pop()
        pt2 = i
        # 已经找到最内层一组[]，进行解码
        temp_s = s[pt1+1:pt2]
        split_idx = temp_s.index('|')
        # 解码插入字符串
        ins_s = temp_s[split_idx+1:]*int(temp_s[:split_idx])
        s = s[:pt1]+ins_s+s[pt2+1:]
        # 解码后i的位置
        i = pt1+len(ins_s)
        length = len(s)
        continue
    i+=1
print(s)
</code></pre>
<h2 id="编程题逛街">[编程题]逛街</h2>
<h3 id="题目-20">题目</h3>
<p>小Q在周末的时候和他的小伙伴来到大城市逛街，一条步行街上有很多高楼，共有n座高楼排成一行。</p>
<p>小Q从第一栋一直走到了最后一栋，小Q从来都没有见到这么多的楼，所以他想知道他在每栋楼的位置处能看到多少栋楼呢？（当前面的楼的高度大于等于后面的楼时，后面的楼将被挡住）</p>
<p><strong>输入描述:</strong></p>
<pre><code>输入第一行将包含一个数字n，代表楼的栋数，接下来的一行将包含n个数字wi(1&lt;=i&lt;=n)，代表每一栋楼的高度。
1&lt;=n&lt;=100000;
1&lt;=wi&lt;=100000; 
</code></pre>
<p><strong>输出描述:</strong></p>
<pre><code>输出一行，包含空格分割的n个数字vi，分别代表小Q在第i栋楼时能看到的楼的数量。
</code></pre>
<p><strong>输入例子1:</strong></p>
<pre><code>6
5 3 8 3 2 5
</code></pre>
<p><strong>输出例子1:</strong></p>
<pre><code>3 3 5 4 4 4
</code></pre>
<p><strong>例子说明1:</strong></p>
<pre><code>当小Q处于位置3时，他可以向前看到位置2,1处的楼，向后看到位置4,6处的楼，加上第3栋楼，共可看到5栋楼。当小Q处于位置4时，他可以向前看到位置3处的楼，向后看到位置5,6处的楼，加上第4栋楼，共可看到4栋楼。
</code></pre>
<h3 id="解答-19">解答</h3>
<p>题中要求向左看和向右两个方向的楼数总和，向左看和向右看的计算方法一样，因此我们先考虑从左侧向右看的楼数总和。对于任意一个位置起始，从左往右看，找到<mark>最长的递增子列</mark>，子列长度即为从左往右看能看到的楼数。同样的从右向左看，可以变为将数列翻转后，从左往右看，然后将对应的结果相加即可。</p>
<pre><code class="language-python">import sys
n = list(map(int,sys.stdin.readline().strip().split()))[0]
v = list(map(int,sys.stdin.readline().strip().split()))
dp_l = [0 for _ in range(n)]
# 向左遍历
stack = [v[0]]
for i in range(1,n):
    dp_l[i] = len(stack)
    # 更新栈
    while True:
        if stack:
            if stack[-1] &lt;= v[i]:
                stack.pop()
            else:
                stack.append(v[i])
                break
        else:
            stack.append(v[i])
            break

dp_r = [0 for _ in range(n)]
v_inv = v[::-1]
# 向右遍历
stack = [v_inv[0]]
for i in range(1,n):
    dp_r[i] = len(stack)
    # 更新栈
    while True:
        if stack:
            if stack[-1] &lt;= v_inv[i]:
                stack.pop()
            else:
                stack.append(v_inv[i])
                break
        else:
            stack.append(v_inv[i])
            break
# 加和
for i in range(n): print(dp_l[i]+dp_r[n-i-1]+1,end=' ')
</code></pre>
<h2 id="编程题逆序对">[编程题]逆序对</h2>
<h3 id="题目-21">题目</h3>
<p>作为程序员的小Q，他的数列和其他人的不太一样，他有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span></span>个数。老板问了小Q一共 m次，每次给出一个整数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>q</mi><mi>i</mi></msub><mo>(</mo><mn>1</mn><mo>≤</mo><mi>i</mi><mo>≤</mo><mi>m</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">q_{i}(1\leq i\leq m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.79549em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span>， 要求小Q把这些数每<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><msub><mi>q</mi><mi>i</mi></msub></msup></mrow><annotation encoding="application/x-tex">2^{q_{i}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:-0.03588em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>分为一组，然后把每组进行翻转，小Q想知道每次操作后整个序列中的逆序对个数是多少呢？</p>
<p>例如:</p>
<p>对于序列1 3 4 2，逆序对有(4, 2),(3, 2),总数量为2。</p>
<p>翻转之后为2 4 3 1，逆序对有(2, 1),(4, 3), (4, 1), (3, 1),总数量为4。</p>
<p><strong>输入描述:</strong></p>
<pre><code>第一行一个数
第二行个数，表示初始的序列()
第三行一个数
第四行m个数表示
</code></pre>
<p><strong>输出描述:</strong></p>
<pre><code>m行每行一个数表示答案。
</code></pre>
<p><strong>输入例子1:</strong></p>
<pre><code>2
2 1 4 3
4
1 2 0 2
</code></pre>
<p><strong>输出例子1:</strong></p>
<pre><code>0
6
6
0
</code></pre>
<p><strong>例子说明1:</strong></p>
<pre><code>初始序列2 1 4 3
 -&gt;
第一次：1 2 3 4 -&gt; 逆序对数为0
 -&gt;
第二次：4 3 2 1 -&gt; 逆序对数为6
 -&gt;
第三次：4 3 2 1 -&gt; 逆序对数为6
 -&gt;
第四次：1 2 3 4 -&gt; 逆序对数为0
</code></pre>
<h3 id="解答-20">解答</h3>
<p><mark>略</mark></p>
<h2 id="编程题假期">[编程题]假期</h2>
<h3 id="题目-22">题目</h3>
<p>由于业绩优秀，公司给小Q放了 n 天的假，身为工作狂的小Q打算在在假期中工作、锻炼或者休息。他有个奇怪的习惯：不会连续两天工作或锻炼。只有当公司营业时，小Q才能去工作，只有当健身房营业时，小Q才能去健身，小Q一天只能干一件事。给出假期中公司，健身房的营业情况，求小Q最少需要休息几天。</p>
<p><strong>输入描述:</strong></p>
<pre><code>第一行一个整数  表示放假天数
第二行 n 个数 每个数为0或1,第 i 个数表示公司在第 i 天是否营业
第三行 n 个数 每个数为0或1,第 i 个数表示健身房在第 i 天是否营业
（1为营业 0为不营业）
</code></pre>
<p><strong>输出描述:</strong></p>
<pre><code>一个整数，表示小Q休息的最少天数
</code></pre>
<p><strong>输入例子1:</strong></p>
<pre><code>4
1 1 0 0
0 1 1 0
</code></pre>
<p><strong>输出例子1:</strong></p>
<pre><code>2
</code></pre>
<p><strong>例子说明1:</strong></p>
<pre><code>小Q可以在第一天工作，第二天或第三天健身，小Q最少休息2天
</code></pre>
<h3 id="解答-21">解答</h3>
<p>小Q每一天有三种选择：工作、健身或者休息。很容易想到这是一道动态规划题目，只是状态数目较多（DP维度稍高）。我们先把问题的描述按点剖析一下：</p>
<ol>
<li>公司/健身房开门才能选择去工作/健身</li>
<li>昨天工作/健身了，无论今天公司/健身房是否开门，都不能继续工作/健身</li>
</ol>
<p>为了更清晰得表达，画成状态转换图为：</p>
<img src="https://s1.ax1x.com/2020/03/22/8oeRmR.png" alt="假期-状态转换图" style="zoom: 50%;" />
<p>我们设定每<code>i</code>天做出工作[1]、健身[2]、休息[0]选择的条件下，所获得的最大非休息天数为<code>dp[i][1]、dp[2][1]、dp[i][0]</code>。状态之间的转换关系为：</p>
<ol>
<li>今天选择休息，则今天的最大非休息天数=max(昨天健身的非休息天数，昨天工作的非休息天数）<code>dp[i][0] = max(dp[i-1][1],dp[i-1][2]</code></li>
<li>如果今天公司开门，则今天可以选择工作，则今天的最大非休息天数=max(昨天健身的非休息天数，昨天休息的最大非休息天数)+1<code>dp[i][1] = max(dp[i-1][0],dp[i-1][2])+1</code></li>
<li>如果今天健身房开门，则今天可以选择工作，则今天的最大非休息天数=max(昨天工作的非休息天数，昨天休息的最大非休息天数)+1<code>dp[i][2] = max(dp[i-1][0],dp[i-1][1])+1</code></li>
</ol>
<p>最终的最大休息天数为：<code>总天数-最后一天的最大非休息天数</code>。代码如下：</p>
<pre><code class="language-python">import sys
n = list(map(int,sys.stdin.readline().strip().split()))[0]
company = list(map(int,sys.stdin.readline().strip().split()))
exer = list(map(int,sys.stdin.readline().strip().split()))
company2 = exer
assert n == len(company) == len(exer)
# 0休息  1 工作  2健身    第i天选择为0/1/2下的最大工作天数
dp = [[0 for i in range(n)] for _ in range(3)]
'''
注意第一天，选择休息，则工作天数=0，跟公司健身房开不开没有半毛钱关系！！！！
'''
dp[0][0] = 0
dp[1][0] = 1 if company[0] == 1 else 0
dp[2][0] = 1 if exer[0] == 1 else 0
# 开始状态转换
for i in range(1,n):
    # 不论是否开门，都可以选择休息！！！！！！！不是只有今天公司和健身房都不开门才休息
    dp[0][i] = max(dp[0][i-1],dp[1][i-1],dp[2][i-1])
    if company[i] == 1:
        # 公司开门
        dp[1][i] = max(dp[0][i-1],dp[2][i-1]) + 1
    if exer[i] == 1:
        # 健身房开门
        dp[2][i] = max(dp[0][i-1],dp[1][i-1]) + 1
print(n-max(dp[0][-1],dp[1][-1],dp[2][-1]))
</code></pre>
<h2 id="编程题视野争夺">[编程题]视野争夺</h2>
<h3 id="题目-23">题目</h3>
<p>小Q在进行一场竞技游戏,这场游戏的胜负关键就在于能否能争夺一条长度为L的河道,即可以看作是[0,L]的一条数轴。</p>
<p>这款竞技游戏当中有n个可以提供视野的道具−真视守卫,第i个真视守卫能够覆盖区间[xi,yi]。现在小Q想知道至少用几个真视守卫就可以覆盖整段河道。</p>
<p><strong>输入描述:</strong></p>
<pre><code>输入包括n+1行。
第一行包括两个正整数n和L(1&lt;=n&lt;=105,1&lt;=L&lt;=109)
接下来的n行,每行两个正整数xi,yi(0&lt;=xi&lt;=yi&lt;=109),表示第i个真视守卫覆盖的区间。 
</code></pre>
<p><strong>输出描述:</strong></p>
<pre><code>一个整数，表示最少需要的真视守卫数量, 如果无解, 输出-1。
</code></pre>
<p><strong>输入例子1:</strong></p>
<pre><code>4 6
3 6
2 4
0 2
4 7
</code></pre>
<p><strong>输出例子1:</strong></p>
<pre><code>3
</code></pre>
<h3 id="解答-22">解答</h3>
<p>为每个右区间找到最小的最区间</p>
<pre><code class="language-python"># 本题通过90%还有BUG
import sys 
texts = []
n,L = list(map(int,sys.stdin.readline().strip().split()))
for line in sys.stdin:
    texts.append(line.split())
for i in range(len(texts)):
    for j in range(len(texts[0])):
        texts[i][j] = int(texts[i][j])
starts = [texts[i][0] for i in range(len(texts))]
end = [min(L,texts[i][1]) for i in range(len(texts))]
from operator import itemgetter
index = [index for index, value in sorted(enumerate(starts), key=itemgetter(1))]
starts.sort()
end = [end[index[i]] for i in range(len(end))]
if not starts[0] == 0:
    print(-1)
    exit()
ans = 0
y = 0
y_next = 0
i = 0
while i &lt; len(starts):
    # 包含y且最远的
    if  starts[i] &lt;= y:
        y_next = max(y_next,end[i])
        i+=1
        continue
    elif end[i] &gt; y_next:
        # 更新y
        y = y_next
        ans+=1
        continue
    i+=1
print(ans+1)
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LRU+递归实现暴力解题]]></title>
        <id>https://zxpzhong.github.io/post/LRU+递归实现暴力解题/</id>
        <link href="https://zxpzhong.github.io/post/LRU+递归实现暴力解题/">
        </link>
        <updated>2020-03-15T10:05:41.000Z</updated>
        <summary type="html"><![CDATA[<p>LRU+递归实现暴力解题</p>
]]></summary>
        <content type="html"><![CDATA[<p>LRU+递归实现暴力解题</p>
<!-- more -->
<h1 id="lru递归实现暴力解题">LRU+递归实现暴力解题</h1>
<h2 id="递归">递归</h2>
<p>递归是一种将问题串行分解为多个完全相同的子问题的方法，递归方法的流程如下：</p>
<ol>
<li>分析整个问题能否分解为多个完全一样的的<mark>串行解决</mark>的子问题（能否递归）</li>
<li>每个串行解决的子问题如何<mark>递归</mark>得到下一个串行解决的子问题（子问题分解）</li>
<li>初始条件和终止条件，结果的汇总一般使用全局变量接收（初始条件和终止条件）</li>
</ol>
<p>但是如果简单只用递归，会造成大量的重复计算。比如Leetcode第91题，”解码方法“中：</p>
<img src="https://s1.ax1x.com/2020/03/15/83WtYR.png" alt="Leetcode 91题" style="zoom:38%;" />
<p>将一个数字字符串解码为A到Z的英文单词。由于解码时，需要考虑”12“是”1“+”2“，得到”AB“；还是”12“，得到”L“，所以后续有很多情况。这题的最优解是采用<mark>动态规划</mark>，为了防止误导大家，我先把这题的一个较好的题解放出来：</p>
<pre><code class="language-python">class Solution(object):
	def numDecodings(self, s):
		length = len(s)
		# 上次结果
		pre = 1
		# 当前结果
		cur = 1
		if s[0] == '0':
			return 0
		ans = 0
		for i in range(1,length):
			temp = cur * (1 if not s[i] == '0' else 0) + pre * (1 if 9&lt;int(s[i-1:i+1]) &lt;= 26 else 0)
			pre = cur
			cur = temp
		return cur
</code></pre>
<p>应用上面的递归思路，将解码一整个字符串分解为多个串行执行的相同子任务，即每次针对输入的字符串，只解码第一个可以正确解码字符组（'1'~'26'），然后递归继续解码，每次递归到剩余字符长度为0，则说明解码方法多出一种，对结果变量进行累加即可。代码如下：</p>
<pre><code class="language-python">class Solution(object):
    def numDecodings(self, s):
        return self.split_one(s)
    def split_one(self,cur_str):
        length = len(cur_str)
        ans = 0
        if length == 0:
            # 分解完毕
            return 1
        if not cur_str[0] == '0':
            ans+=self.split_one(cur_str[1:])
            if length &gt;= 2 and int(cur_str[:2]) &lt;= 26:
                # 两位也可以拿出来解释
                ans+=self.split_one(cur_str[2:])
        return ans
</code></pre>
<p>当然这样是超时了：</p>
<img src="https://s1.ax1x.com/2020/03/15/83oKp9.png" alt="递归超时" style="zoom:50%;" />
<h2 id="递归超时的原因">递归超时的原因</h2>
<p>一般而言对于题目最暴力的解法是穷举所有的可能，递归就是穷举法的一种相对还比较优雅的实现，没有改进或者剪枝的递归和暴力穷举的复杂度是相同的。递归超时的主要原因在于：算法经过不同路径到达同一个状态后，虽然这是同一个状态且后续路径即使完全相同，这也算是完全不同的两种解法，后续的路径会被反复重复计算。</p>
<p>比如上题中，对于字符串”1121“，如果使用暴力解法穷举，则：</p>
<pre><code class="language-python">'1'	-&gt; '1'	-&gt; '2'	-&gt; '1'
						-&gt; '21'
		-&gt; '12'	-&gt; '1'
'11'-&gt; '2'	-&gt; '1'
		-&gt; '21'
</code></pre>
<p>对于上述第一行和第四行中，使用'1'+'1'和使用'11'后，剩余字符都是'21'，也就是通过不同路径到达同一状态，但是暴力递归对于后续相同的'21'分解，完全重复了两遍运算，并且随着问题的输入规模增大，重复计算量将非常的大，导致程序运行超时。</p>
<h2 id="利用lru减少递归中的重复计算">利用LRU减少递归中的重复计算</h2>
<p>根据上面的分析，我们找到了重复计算的根源，并且某个子问题的输出只与其输入有关，理所应当会想到，我们将所有的输入和输出通过字典储存，在每次运算时，都去字典查找是否计算过相同输入的输出，如果是则直接取输出，否则才计算。这种方法叫做==<a href="https://zh.wikipedia.org/wiki/%E8%AE%B0%E5%BF%86%E5%8C%96">Memoization（记忆化）</a>==。记忆化是一种提高程序运行速度的优化技术。通过储存大计算量函数的返回值，当这个结果再次被需要时将其从缓存提取，而不用再次计算来节省计算时间。 记忆化是一种典型的时间存储平衡方案。</p>
<p>某个方法很多次，在这很多次的调用中，部分计算是完全可重用的，则可以设计一个缓存机制，将中间的一些重要中间结果缓存下来，如果后续的运算命中了之前的缓存，则可以减少重复计算，提升程序效率。</p>
<p>python的LRU(Least Recently Used)为我们提供了这样一种缓存机制，只需要在函数前面加上<code>@functools.lru_cache()</code>就可以实现。我们使用上面递归超时的例子：</p>
<pre><code class="language-python">import functools
class Solution(object):
    def numDecodings(self, s):
    # 尝试加入LRU cache来让原来超时的解法通过
        self.ans = 0
        return self.split_one(s)
    @functools.lru_cache()
    def split_one(self,cur_str):
        length = len(cur_str)
        ans = 0
        if length == 0:
            # 分解完毕
            return 1
        if not cur_str[0] == '0':
            ans+=self.split_one(cur_str[1:])
            if length &gt;= 2 and int(cur_str[:2]) &lt;= 26:
                # 两位也可以拿出来解释
                ans+=self.split_one(cur_str[2:])
        return ans

</code></pre>
<p>结果：</p>
<img src="https://s1.ax1x.com/2020/03/15/83oghQ.png" alt="LRU结果" style="zoom:50%;" />]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode标签含义汇总]]></title>
        <id>https://zxpzhong.github.io/post/leetcode算法题标签含义汇总/</id>
        <link href="https://zxpzhong.github.io/post/leetcode算法题标签含义汇总/">
        </link>
        <updated>2020-03-15T06:54:41.000Z</updated>
        <summary type="html"><![CDATA[<p>Leetcode标签含义汇总</p>
]]></summary>
        <content type="html"><![CDATA[<p>Leetcode标签含义汇总</p>
<!-- more -->
<h1 id="leetcode算法题标签含义汇总">leetcode算法题标签含义汇总</h1>
<h2 id="array">Array</h2>
<p>这个分类意义为数组，属于按输入类型的粗分类，只要和数组相关就会被分到该类下，所以对具体方法参考意义不大。</p>
<h2 id="backtracking">Backtracking</h2>
<p>回溯法。主要是针对暴力解法或者暴力递归过程中，如何减少可能出现大量的重复运算。比如运算到第K步，如果是暴力递归，那么每一次运算到第K步都需要计算前K步，但是对于回溯，可能避免重复计算前K步，是使用回溯还是递归，主要取决于运算过程中是否包含大量的重复计算。</p>
<h2 id="binary-indexed-tree">Binary Indexed Tree</h2>
<p>树状数组。<a href="https://blog.csdn.net/Jasmineaha/article/details/81462020">Binary Indexed Tree解释</a>，详见[分割树](##Segment Tree)。</p>
<h2 id="binary-search">Binary Search</h2>
<p>二分搜索。思想来源于排序数组的二分搜索，这个思想也可以用在很多排序问题搜索的问题上。</p>
<h2 id="bit-manipulation">Bit Manipulation</h2>
<ol>
<li>位操作，包含（示例代码使用python，变量<code>a = 3(0011) b = 4(0101)</code>）：</li>
</ol>
<ul>
<li>
<p>与：<code>a&amp;b = 1(0001)</code></p>
</li>
<li>
<p>或：<code>a|b = 7(0111)</code></p>
</li>
<li>
<p>非：<code>~a = -4</code>(3取反后首位为1，是负数，负数以补码形式储存得-4)</p>
</li>
<li>
<p>左移：<code>a&lt;&lt;1 = 6</code></p>
</li>
<li>
<p>右移：<code>a&gt;&gt;1 = 1</code></p>
</li>
<li>
<p>置位：<code>a = a|(2**2)</code>(对第二位置位，python没有置位操作，可以用或完成)</p>
</li>
<li>
<p>复位：<code>a = a&amp;(255-2**2)</code>(第二位复位，python没有置位操作，可以用或完成)</p>
</li>
<li>
<p>异或：<code>a^b = 0110</code>(相同为0，不同为1)</p>
</li>
</ul>
<ol start="2">
<li>位操作中比较经典的就是格雷码（Gray Code），格雷码是相邻两个编码有且只有一位差别，基础且经典的问题是格雷码的生成问题，有以下两个方法：</li>
</ol>
<ul>
<li>
<p>按位数生成序列：已知两位的格雷码为：<code>00 01 11 10</code>,从三位的格雷码开始，先在二位的格雷码<strong>前</strong>添加0得到：<code>000 001 011 010</code>，再添加<code>1</code>并且调换两个的顺序得到：<code>110 111 101 100</code>，拼接后得到三位格雷码为：<code>000 001 011 010 110 111 101 100</code>，以此类推可以得到四位，五位。。。</p>
</li>
<li>
<p>（推荐）直接生成第n位格雷码：<code>Gray(n) = n XOR n/2</code></p>
</li>
</ul>
<h2 id="brain-teaser">Brain teaser</h2>
<p>智力题。这个分类其实不是很准确，只是算法题套上了智力题的外套，核心的算法部分各有不同，由于是动态的游戏过程，动态规划的方法可能比较适用。</p>
<h2 id="breadth-first-search">Breadth First Search</h2>
<p>广度优先搜索（BFS）。这个是最最基础的树遍历算法了，也叫做<strong>按层扫描输出</strong>。当然不仅仅在树搜索中很有用，更重要的是这个思想，可以用在很多需要提前停止的迭代过程中（BFS本身也是一种递归），最重要的是设计明确何时停止，递归调用如何一级一级返回，如果传回有用参数。这类题目的特点是：某问题<strong>有无</strong>符合条件的解/给出一个符合条件的解。</p>
<h2 id="depth-first-search">Depth First Search</h2>
<p>深度优先搜索（DFS）。这个也是最基础的数遍历算法了，在二叉树中根据取到左子叶、中节点和右子叶的顺序可以分为前序遍历、中序遍历和后续遍历。如同BFS一样，这种思想也很重要，这类问题的核心目标在于如何在深度优先搜索过程中进行剪枝，如果不进行剪枝，那么和暴力递归的复杂度一样了，基本上都会超时的。这列题目的特点是：给出某问题<strong>所有</strong>符合条件的解。</p>
<h2 id="design">Design</h2>
<p>设计。一般是要求你设计能实现某种功能的数据结构（堆栈、队列、链表、树、图、字典），当然肯定是和普通的不完全一样，但是也是基于基本的数据结构上进行修改的！</p>
<h2 id="divide-and-conquer">Divide And Conquer</h2>
<p>分治法。分治法也是把问题分块，只不过和递归的那种问题分块方法不同，分治法的分割方法是分割成完全独立的小问题，最终再将各个子问题的结果合并，可以看做各个问题是<strong>并行</strong>解决的。而递归的子问题，是每次解决问题时的一小部分然后用这一步的结果作为下一步的初始状态，是<strong>串行</strong>解决的。</p>
<h2 id="dynamic-programming">Dynamic Programming</h2>
<p>动态规划。解题神器！！动态规划的核心是建立状态和动态转移方程的概念（可以用状态机标识），每一步的决策都与只与特定的状态相关联，一般用递归或者DFS超时的，都可以考虑DP，再广泛一点说，只要是做动态决策的，基本上都可以用DP方法解决，而且复杂度一般来讲都是最低的（一般是O(nm),m为单次决策的复杂度）！！</p>
<p>动态规划的思考流程：</p>
<ol>
<li>动态决策过程中，当前的最优选项是否只取决于当前或过去的状态（能否用动态规划解决）</li>
<li>当前的最优选项是否能够用历史状态表达（<mark>转移方程</mark>，等价于可以用状态机表示）</li>
<li>最终问题的解与状态的关系（输出）</li>
</ol>
<h2 id="geometry">Geometry</h2>
<p>几何。这个标签含义不明，该标签下一共三题，一题二维平面，一题图的传播，第三题与几何无关</p>
<h2 id="graph">Graph</h2>
<p>图。</p>
<h2 id="greedy">Greedy</h2>
<p>贪心算法。解决一个问题需要很多步，但是每一步都选择当前状态下最优的选择，并且最终的最优结果也是每一步的最优结果的堆叠（当然很多问题是不符合这个的，所以要取决于最终问题，如果某步不是最优，可能再用回溯的方法回到当前步再取次优）！贪心算法的步骤大约可以分为三步：</p>
<ol>
<li>
<p>确定初始条件</p>
</li>
<li>
<p>采用迭代的过程，当可以向目标前进一步时，就根据局部最优策略，得到一部分解，缩小问题规模</p>
</li>
<li>
<p>将所有解综合起来</p>
</li>
</ol>
<h2 id="hash-table">Hash Table</h2>
<p>哈希表（散列表）。是储存键值对数据的一种数据储存方式，如果采用列表储存键值对数据，则需要的空间复杂度为O(2n)，单次查找的时间复杂度为O(n)，可以将所以找到索引值的时间复杂度降为O(1)。其核心在于哈希函数的设计，即如何设计键（key）和地址的计算关系。常用的哈希函数构造方法有：</p>
<ol>
<li>直接定址法：取关键字或者关键字的某个线性函数为Hash地址，即address(key)=a*key+b;如知道学生的学号从2000开始，最大为4000，则可以将address(key)=key-2000作为Hash地址。</li>
<li>平方取中法：对关键字进行平方运算，然后取结果的中间几位作为Hash地址。假如有以下关键字序列{421，423，436}，平方之后的结果为{177241，178929，190096}，那么可以取中间的两位数{72，89，00}作为Hash地址。</li>
<li>折叠法：将关键字拆分成几部分，然后将这几部分组合在一起，以特定的方式进行转化形成Hash地址。假如知道图书的ISBN号为8903-241-23，可以将address(key)=89+03+24+12+3作为Hash地址。</li>
<li>除留取余法：如果知道Hash表的最大长度为m，可以取不大于m的最大质数p，然后对关键字进行取余运算，address(key)=key%p。</li>
</ol>
<p>看完上面哈希函数的设计，理所当然得会想到，上面任意一中哈希函数方法在进行计算地址时，地址都会出现不连续的情况，所以在分配哈希表时，必须提前预分配一个更大的空间，造成空间的浪费；或者因为分配的空间太小，造成哈希冲突，所以哈希表大小的确定也十分重要（这里我也不懂了）。上面提到的哈希冲突，即两个不同的键值对通过哈希函数的映射后储存于同一地址的情况，这样会造成数据的丢失。哈希冲突一般有<a href="https://www.jianshu.com/p/de33dc676a3f">两种解决办法</a>：</p>
<ol>
<li>开放定址法：即当一个关键字和另一个关键字发生冲突时，使用某种探测技术在Hash表中形成一个探测序列，然后沿着这个探测序列依次查找下去，当碰到一个空的单元时，则插入其中。比较常用的探测方法有线性探测法，比如有一组关键字{12，13，25，23，38，34，6，84，91}，Hash表长为14，Hash函数为address(key)=key%11，当插入12，13，25时可以直接插入，而当插入23时，地址1被占用了，因此沿着地址1依次往下探测(探测步长可以根据情况而定)，直到探测到地址4，发现为空，则将23插入其中。</li>
<li>采用数组和链表相结合的办法，将Hash地址相同的记录存储在一张线性表中，而每张表的表头的序号即为计算得到的Hash地址。</li>
</ol>
<p>在实际使用中，python的dict就是哈希表，哈希的思想也可以用在很多需要重复索引某一值的情况，可以一次遍历构造哈希表O(n)，之后的索引就可以在O(1)下完成了！</p>
<h2 id="heap">Heap</h2>
<p>堆。讲到堆，肯定有人会想到栈，还有堆栈，列表和队列。那么这些名称分别有什么相同和不同呢。首先来区分堆/栈/堆栈、列表和队列：</p>
<ul>
<li>列表：大家最常用了，它是顺序储存的，即相邻元素储存于连续地址中，所以他的索引速度是最快的，只需要O(1)，但是插入元素的时则需要频繁得移动元素到后面去，最大的插入操作复杂度为O(n)。（<strong>c++11是这样，python待验证</strong>，如果脱离具体语言实现去思考的话，确实是这样的）</li>
<li>队列：现进先出</li>
<li>堆/栈/堆栈
<ul>
<li>栈（堆栈）：先进后出，一种数据结构</li>
<li>堆：程序运行时动态申请的内存，比如调用函数时的局部变量，运算过程中申请开辟的内存都属于堆，栈是堆的一种使用方法（先进后出，最经典的就是函数调用时，保护现场和还原现场时的入栈和出栈操作）。所以说堆不能完全算作一种数据结构，只不过在不同的语言或者领域中，有时候叫栈有时候叫堆栈，所以很多人把堆的概念也混进来了！</li>
</ul>
</li>
</ul>
<h2 id="line-sweep">Line Sweep</h2>
<p><a href="https://www.jianshu.com/p/d9be99077c2b">扫面线算法</a>。大概的内容是：二维平面上的多边形在图像中可以以坐标列表（比如[[2,2],[5,1],[11,3]]）的形式表示，如果需要转化为二维平面上的图形显示出来，需要对多边形内部进行填充。线扫描算法的思想就是利用一条条水平线对图像进行扫描，并且对处于多边形内部的区域进行填充，大致的原理是这样，但是具体的实现上还是需要注意很多细节。</p>
<img src="https://s1.ax1x.com/2020/03/14/8Q8q4P.png" style="zoom:60%;" />
<p>这个Tag下只有三道题目,其中[880]可以用逐层分解字符串的方法解出，[218] [391]可以使用扫描线算法的思想解出。</p>
<h2 id="linked-list">Linked List</h2>
<p>链表。链表是逻辑上具有一定顺序，空间上可以任意排布的一种数据结构（链表的索引复杂度为O(n)，插入操作在定位到元素后只需要修改指针值即可完成插入，而不需要像连续储存的数据结构，每次增删需要移动后续所有的元素），也是一种递归的数据结构。根据链表的连接方式可以分为：</p>
<ul>
<li>单向链表：每个节点（Node）只包含指向下一个元素的指针，无法从链表中间的任一元素追溯到上一元素。</li>
<li>双向链表：每个节点包含一个向下一个向上的指针，可以由任一节点追溯到整个链表。C++11中的<code>list</code>容器采用双向链表实现，具有极快的随机增删速度。</li>
<li>循环链表：首尾相接的链表，拓扑结构上呈现一个环状。</li>
</ul>
<p><strong>Tips</strong>: python的list可以使用下表直接索引，是因为list采用数组的形式储存。那为什么list可以放入不同类型的元素呢？因为python的list中存入的其实是元素的地址，python中对变量的值修改并不会直接修改该内存区域的值，而是变量指向另一片储存区域。</p>
<p><strong>链表必备方法</strong>：</p>
<ol>
<li>链表的正序逆序索引：正序索引O(n)，逆序索引O(2n)</li>
<li><mark>链表翻转</mark>：O(n)</li>
<li>判断是否有环：双指针</li>
<li>删除重复元素</li>
<li>还有很多变种，还没来得及整理！</li>
</ol>
<h2 id="math">Math</h2>
<p>数学。这个分类比较杂，只要涉及数学运算的好像都会被放到这个分类下来，比如四则运算、质数、丑数、指数运算、幂运算、排列组合等等，所采用的的方法和具体题型有关。</p>
<h2 id="memoization">Memoization</h2>
<p><a href="https://zh.wikipedia.org/wiki/%E8%AE%B0%E5%BF%86%E5%8C%96">记忆化</a>。在计算机科学中，记忆化是一种提高程序运行速度的优化技术。通过储存大计算量函数的返回值，当这个结果再次被需要时将其从缓存提取，而不用再次计算来节省计算时间。 记忆化是一种典型的时间存储平衡方案。</p>
<p>比如需要调用某个类的某个方法很多次，在这很多次的调用中，部分计算是完全可重用的，则可以设计一个缓存机制，将中间的一些重要中间结果缓存下来，如果后续的运算命中了之前的缓存，则可以减少重复计算，提升程序效率。</p>
<p>暴力递归变为回溯法可以看做一种记忆化方法。</p>
<p>缓存的用处：</p>
<ul>
<li>浏览器缓存</li>
<li>DNS缓存</li>
<li><a href="https://blog.csdn.net/lynn_Kun/article/details/77463779">数据库的读取</a></li>
<li>CPU的多级缓存</li>
<li>硬盘数据读取缓存</li>
</ul>
<p>leetcode该分类下只有一题[329]，其实还有其他题目，但是我懒得找了，不在这列举了！</p>
<h2 id="minimax">Minimax</h2>
<p><a href="https://www.zhihu.com/question/27221568">极大值极小值算法</a>。极大值极小值算法是一种DFS算法， 如果游戏较为简单（比如井字棋），可以通过DFS遍历出所有的可能步骤和对应的结果，然后通过极大值极小值算法反推出在任何一步，你应该如何执行操作。（井字棋机器人我本科的时候还拿Uarm机械臂和摄像头做过  - - ！）</p>
<p>当然井字棋可以穷举，但是对于绝大部分的游戏，都无法进行穷举，只可能考虑接下来的几步，因此需要对当前和接下来的某几步所产生的局面进行评分，这个评分的函数称作估值函数。极大极小方法往往指的是基于静态估值函数的有限深度的极大极小搜索，即可以对每个局面进行静态打分，而与之前的局面无关，再对有限深度（比如3步）进行极大极小搜索，从而得出当前应该执行什么操作。</p>
<h2 id="ordered-map">Ordered Map</h2>
<p>排序字典。前面提到了Hash Table，python中的字典就是Hash Table，但是字典中的键值对没有顺序，对字典进行遍历输出时，键值对的输出顺序没有含义(与加入字典的顺序无关)。但是对于pyhton的排序字典（OrderedDict）而言，键值对在加入字典时，会像列表一样，添加在尾部，从而在遍历排序字典时，可以获得和输入顺序同样的遍历顺序。</p>
<p><strong>经过验证，python2、3的dict都会按添加顺序输出！但是如果确实需要保证输出顺序时，还是建议使用OrderedDict</strong></p>
<pre><code class="language-python">import collections
print('Regular dictionary:')
d={}
d['a']='A'
d['c']='C'
d['z']='Z'
d['b']='B'
for k,v in d.items():
    print(k,v)
print('OrderedDict:')
d=collections.OrderedDict()
d['a']='A'
d['c']='C'
d['z']='Z'
d['b']='B'
for k,v in d.items():
    print(k,v)
</code></pre>
<p>输出为：</p>
<pre><code class="language-python">Regular dictionary:
a A
c C
z Z
b B
OrderedDict:
a A
c C
z Z
b B
</code></pre>
<h2 id="queue">Queue</h2>
<p><a href="https://zhuanlan.zhihu.com/p/81018602">队列</a>。先入先出（First In First Out, FIFO）的数据结构。</p>
<pre><code class="language-python">import queue
q = queue.Queue()
for i in range(4):
    q.put(i)
while not q.empty():
    print(q.get())
</code></pre>
<p>输出为：</p>
<pre><code>0
1
2
3
</code></pre>
<p>由于队列的性质比较简单，该Tag下的题目较少，而且也都比较简单。除了使用python3内置的<code>queue</code>当然更多时候我们可以选择使用<code>list</code>手动实现一个队列。因为list用的多顺手嘛。</p>
<h2 id="random">Random</h2>
<p>这个分类也不知道啥含义，Tag含义为随机，对应到分类下的题目，是想说这些题中都存在一定的随机过程，但是很多题都有随机过程啊，而且大多数题目最终在限制条件下的最优解一般只有一个。</p>
<h2 id="recursion">Recursion</h2>
<p>递归。递归由于其太过暴力，往往会因为超过复杂度限制而被抛弃，但是在很多改进的剪枝方法中，原始的递归的思想都非常重要！！但是这个分类下却只有10道题，还是分类没有分好。。。</p>
<p>递归的构建流程相对会简单很多，但是往往会造成大量重复运算（复杂度一般等价于暴力grid search），作为第一眼看到想出的方法或者想不出其他方法时可以尝试一下，万一AC了呢？</p>
<ol>
<li>分析整个问题能否分解为多个完全一样的的<mark>串行解决</mark>的子问题（能否递归）</li>
<li>每个串行解决的子问题如何递归得到下一个串行解决的子问题（子问题分解）</li>
<li>初始条件和终止条件，结果的汇总一般使用全局变量接收（初始条件和终止条件）</li>
</ol>
<h2 id="rejection-sampling">Rejection Sampling</h2>
<p>拒绝采样，也叫做接受/拒绝采样（Accept-Reject Sampling）。比如要在一个矩形中实现均匀采样，可以对横纵坐标都从均匀分布中采样，但是如果要对圆均匀采样呢，甚至是对不规则图形进行均匀采样，就比较困难了，因为要构建在非矩形图形中构建均匀采样的概率分布大多数情况下是比较麻烦的。</p>
<p>对于分布<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">p(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>，选取一个容易采样的参考分布<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>q</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">q(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>，使得对于任意的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>都有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>⩽</mo><mi>M</mi><mo>⋅</mo><mi>q</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">p(x) \leqslant M \cdot q(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">⩽</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>,则可以按照如下过程进行采样：</p>
<ol>
<li>从参考分布<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>q</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">q(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>中随机抽取一个样本<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">x_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li>
<li>从均匀分布<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>U</mi><mo>(</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">U(0,1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>产生一个随机数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>u</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">u_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li>
<li>如果<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>u</mi><mi>i</mi></msub><mo>&lt;</mo><mfrac><mrow><mi>p</mi><mo>(</mo><msub><mi>x</mi><mi>i</mi></msub><mo>)</mo><mo>)</mo></mrow><mrow><mi>M</mi><mi>q</mi><mo>(</mo><msub><mi>x</mi><mi>i</mi></msub><mo>)</mo><mo>)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">u_{i}&lt;\frac{p(x_i))}{Mq(x_i))}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6891em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.53em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">M</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">q</span><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mclose mtight">)</span><span class="mclose mtight">)</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">p</span><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mclose mtight">)</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>,则接受样本<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">x_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，否则拒绝，重复直到接受</li>
</ol>
<h2 id="reservoir-sampling">Reservoir Sampling</h2>
<p><a href="https://www.jianshu.com/p/63f6cf19923d">蓄水池采样</a>。在一个给定长度的数组中随机等概率抽取一个数据很容易，但如果面对的是<mark>长度未知</mark>的海量数据流呢？蓄水池采样算法就是来解决这个问题的, 它在分析一些大数据集的时候非常有用。</p>
<ol>
<li>先选取数据流中的前<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>个元素，保存在集合<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span>中</li>
<li>从第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi><mo>(</mo><mi>k</mi><mo>+</mo><mn>1</mn><mo>&lt;</mo><mo>=</mo><mi>j</mi><mo>&lt;</mo><mo>=</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">j(k+1&lt;=j&lt;=n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>个元素开始，每次先以概率<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mo>=</mo><mi>k</mi><mi mathvariant="normal">/</mi><mi>j</mi></mrow><annotation encoding="application/x-tex">p=k/j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>选择是否让第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>个元素留下。若<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>被选中，则从A中随机选择一个元素并用该元素<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>替换它；否则直接淘汰该元素</li>
<li>重复步骤2直到结束，最后集合<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span>中剩下的就是保证随机抽取的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>个元素</li>
</ol>
<h2 id="segment-tree">Segment Tree</h2>
<p><a href="https://www.jianshu.com/p/6fd130084a43">线段树</a>。对于普通的线性储存数组<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span>，对于更新操作<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">a[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>的复杂度为O(1)，对于区间操作（比如区间求和，区间最小值、最大值）的复杂度为O(n)；而树状数组、线段树可以让更新和区间操作的复杂度都变为O(logn)。树状数组和线段树最大的区别在于，树状数组的每一个节点只保留了<strong>左子树</strong>，而线段树一般为<strong>完全二叉树</strong>（即满树），且树状数组要求不同层级的树之间可以满足加法运算。</p>
<h3 id="树状数组">树状数组</h3>
<p>要了解线段树，我们先来看<a href="https://blog.csdn.net/Jasmineaha/article/details/81462020">树状数组</a>。</p>
<img src="https://s1.ax1x.com/2020/03/15/81hn6f.png" alt="树状数组" style="zoom:50%;" />
<ol>
<li>
<p>上图是树状数组构造的一个过程，其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mn>1</mn><mo>−</mo><mi>A</mi><mn>8</mn></mrow><annotation encoding="application/x-tex">A1-A8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">A</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mord">8</span></span></span></span>是原始的线性储存数组(<strong>下标从1开始</strong>)，先要求对该数组进行更新和区间求和操作，更新操作复杂度为O(1)：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>=</mo><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">A[i]=target</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">A</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span></span></span></span>，区间<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>k</mi><mo separator="true">,</mo><mi>t</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[k,t]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">t</span><span class="mclose">]</span></span></span></span>求和操作复杂度为O(n)：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mi>k</mi></mrow><mi>t</mi></msubsup><mi>A</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">\sum_{i=k}^{t}A[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.233166em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.933456em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">A</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>。我们按照如下公式构建树状数组：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>C</mi><mi>i</mi></msub><mo>=</mo><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mi>i</mi><mo>−</mo><msup><mn>2</mn><mi>k</mi></msup><mo>+</mo><mn>1</mn></mrow><mi>i</mi></munderover><mi>A</mi><mo>[</mo><mi>j</mi><mo>]</mo><mo separator="true">,</mo><mi>k</mi><mo>=</mo><mi>l</mi><mi>o</mi><mi>w</mi><mi>b</mi><mi>i</mi><mi>t</mi><mo>(</mo><mi>j</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">C_i=\sum_{j=i-2^k+1}^{i}A[j],k=lowbit(j)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.3112020000000006em;vertical-align:-1.4995329999999998em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8116690000000006em;"><span style="top:-1.786575em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">=</span><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7820285714285713em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.4995329999999998em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">A</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">b</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span></span></p>
<p>其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><mi>w</mi><mi>b</mi><mi>i</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">lowbit</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">b</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span></span></span></span>运算为获取输入参数转为二进制后,最后一个1的位置所代表的数值：</p>
<pre><code class="language-python">def lowbit(x):
	reutrn x&amp;(-x)
</code></pre>
</li>
<li>
<p>根据上面的公式，我们可以得到</p>
<pre><code class="language-python">C1 = A1
C2 = A1 + A2
C3 = A3
C4 = C2 + C3 + A4 = A1 + A2 + A3 + A4
C5 = A5
C6 = C5 + A6 = A5 + A6
C7 = A7
C8 = C4 + C6 + C7 + A8 = A1 + A2 + A3 + A4 + A5 + A6 + A7 + A8
</code></pre>
<p>上面的公式和图中的完全对应上。那么接下来我们看看新构建的树状数组<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span>更新和区间求和的复杂度。</p>
</li>
<li>
<p><mark>更新操作</mark>：我们现在有已经构建好的树状数组<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span>，要对原数组中的某一个数实现更新，即对某一个数加上某一个数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi><mo separator="true">,</mo><mi>v</mi><mo>=</mo><mi mathvariant="normal">Δ</mi><mi>x</mi><mo>=</mo><msup><mi>x</mi><mo mathvariant="normal">′</mo></msup><mo>−</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">v,v=\Delta x=x&#x27;-x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Δ</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.835222em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>，那么对于树状数组，就是对包含有该位置的元素的所有节点加上<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span>。由于树状数组的深度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">logn</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span></span></span></span>，因此更新操作复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>：</p>
<pre><code class="language-python">def add(p,v):
  while p &lt;= n:
		nums[p] += v;
		p += lowbit(p)
    
</code></pre>
</li>
<li>
<p>区间求和操作：区间<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">(l,r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span>(<mark>左开右闭区间</mark>)的和为：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>u</mi><msub><mi>m</mi><mo>(</mo></msub><mi>r</mi><mo>)</mo><mo>−</mo><mi>s</mi><mi>u</mi><mi>m</mi><mo>(</mo><mi>r</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">sum_(r)-sum(r)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1052em;vertical-align:-0.3551999999999999em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mopen mtight">(</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">)</span></span></span></span>，区间求和复杂度也就<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>。</p>
<pre><code class="language-python">def sum_(p):
  ans =0
	while p&gt;0:
    ans += nums[p]
    p -= lowbit(p)
	return ans;    
</code></pre>
</li>
</ol>
<h3 id="线段树">线段树</h3>
<ol>
<li>
<p>从上面树状数组的定义可以看出，能实现快速区间操作的<mark>关键</mark>在于，可以通过左节点的值和当前子树的值，通过加减运算直接得出右子树的值，也就是满足加法运算法则，当然不只是加法，只要满足<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>+</mo><mi>b</mi><mo>=</mo><mi>c</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">则</mi><mi>c</mi><mo>−</mo><mi>a</mi><mo>=</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a+b=c，则c-a=b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">c</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">则</span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span>的运算都可以用树状数组实现。但是很多操作也不满足加法运算，比如经典的取最大取最小操作，这个时候就可以借助线段树实现更新和区间查询复杂度都为O(logn)。</p>
<img src="https://s1.ax1x.com/2020/03/15/81TvfH.png" alt="线段树" style="zoom:50%;" />
</li>
<li>
<p>比如上述的橘色数组，我们要其进行更新和区间最小值运算，更新复杂度和区间运算复杂度分别为O(1)和O(n)，线段树相对来说更好理解的一点是：它其实是利用了分治的思想来构建线段树。上图橘色数组对应的线段树为：</p>
<img src="https://s1.ax1x.com/2020/03/15/81HTZ6.png" alt="线段树" style="zoom:50%;" />
<p>线段树每一个位置代表原数组的区间为：</p>
<pre><code class="language-python">segmentTree[1] = arr[0:8] # python的[a:b]为左闭右开区间[a,b)
segmentTree[2] = arr[0:4]
segmentTree[3] = arr[4:8]
segmentTree[4] = arr[0:2]
segmentTree[5] = arr[2:4]
segmentTree[6] = arr[4:6]
segmentTree[7] = arr[6:8]
segmentTree[8] = arr[0]
segmentTree[9] = arr[1]
segmentTree[10] = arr[2]
segmentTree[11] = arr[3]
segmentTree[12] = arr[4]
segmentTree[13] = arr[5]
segmentTree[14] = arr[6]
segmentTree[15] = arr[7]
</code></pre>
</li>
<li>
<p>更新操作：</p>
<pre><code class="language-python">def update(i, value):
  i = i + n
  segmentTree[i] = value
  while i &gt; 1:
    i = i / 2
    segmentTree[i] = merge(segmentTree[2*i], segmentTree[2*i+1])
</code></pre>
</li>
<li>
<p>区间查询：</p>
<pre><code class="language-python">import sys
def minimum(left, right):
  left = left + n
  right = right + n
  minimum = sys.maxsize
  while left &lt; right:
    if left%2 == 0:
      # left is out of range of parent interval, check value of left node first, then shift it right in the same level
      minimum = min(minimum, segmentTree[left])
      left = left + 1
    if right%2 == 0:
      # right is out of range of current interval, shift it left in the same level and then check the value
      right = right - 1
      minimum = min(minimum, segmentTree[right])
    # move left and right one level up
    left = left / 2
    right = right / 2
</code></pre>
</li>
</ol>
<h2 id="sliding-window">Sliding Window</h2>
<p><a href="https://www.zhihu.com/question/314669016">滑动窗口算法</a>。这个方法对于我们做CV的人来说真的太熟悉了，不过多介绍了😊。</p>
<p>它可以用以解决数组/字符串的子元素问题，它可以将嵌套的循环问题，转换为单循环问题，降低时间复杂度。滑动窗口算法的<strong>核心</strong>在于，每次滑动窗口后，只需要在原来窗口的的基础上额外考虑移出窗口的元素和新移入窗口的元素，而不需要考虑窗口的长度。从而让整个过程的复杂度从O(mn)降为O(n)，其中m为窗口长度。</p>
<h2 id="sort">Sort</h2>
<p><a href="https://www.cnblogs.com/Mufasa/p/10527387.html">十大经典排序算法</a>。</p>
<h3 id="分类">分类</h3>
<ol>
<li>
<p>比较类排序</p>
<ul>
<li>
<p>交换排序</p>
<ul>
<li><mark>冒泡排序</mark>：前后元素比较后，进行<mark>交换（冒泡）</mark>，每<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>轮都会将第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>大的数据放到数组尾部，需要重复<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>次，每次遍历的元素个数为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mi>i</mi></mrow><annotation encoding="application/x-tex">n-i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>，最终的复杂度为O(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mi>n</mi><mo>(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{n(n+1)}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.355em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>)​=O(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">n^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>)。原地修改，空间复杂度为O(1)。</li>
<li><a href="https://wiki.jikexueyuan.com/project/easy-learn-algorithm/fast-sort.html">快速排序</a>：选取一个基准值，从数组两端分别遍历，然后小数在左大数在右的原则进行交换。</li>
</ul>
</li>
<li>
<p>插入排序</p>
<ul>
<li><mark>简单插入排序</mark>：逐个插入到前面的有序数中。第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>轮迭代，将第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>个数插入到前<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>个数中并且仍然保证插入后前<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>个数仍为有序数列。时间复杂度为O(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mi>n</mi><mo>(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{n(n+1)}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.355em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>)=O(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">n^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>)。原地修改，空间复杂度为O(1)。</li>
<li><mark><a href="https://www.cnblogs.com/chengxiao/p/6104371.html">希尔排序</a></mark>：从大范围到小范围进行比较-交换，类似冒泡和插入的联合。</li>
</ul>
</li>
<li>
<p>选择排序</p>
<ul>
<li><mark>简单选择排序</mark>：第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>轮遍历选择第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>小的数放在前面，选择第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>小的数后直接与第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>个数进行交换。第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>轮的筛选范围从第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>个元素开始，因此最终的复杂度为O(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mi>n</mi><mo>(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{n(n+1)}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.355em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>)=O(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">n^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>)。原地修改，空间复杂度为O(1)。</li>
<li>堆排序：利用最大堆和最小堆的特性</li>
</ul>
</li>
<li>
<p>归并排序（分治法插入排序）</p>
<ul>
<li>二路归并排序，依次按前2个前4个前8个前16个。。。进行插入排序。</li>
<li>多路归并排序</li>
</ul>
</li>
</ul>
</li>
<li>
<p>非比较类排序</p>
<ul>
<li>计数排序：字典计数-还原，空间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>+</mo><mi>k</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n+k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span>，直接对数字进行字典计数然后按键的大小顺序还原值个键，典型的空间换时间方法！</li>
<li><a href="https://dailc.github.io/2016/12/03/baseKnowlenge_algorithm_sort_bucketSort.html">桶排序</a>：分为K个桶，将最大到最小值分为平分为K个区间（桶），每个桶在分数据的时候维护桶内一个排序堆，当所有的数据都分完，各个桶的数据再串联起来，就得到结果。是最快也是最耗空间的方法！</li>
<li><a href="https://www.cnblogs.com/sun/archive/2008/06/26/1230095.html">基数排序</a>：基数排序的主要思路是,将所有待比较数值(<strong>注意,必须是正整数</strong>)统一为同样的数位长度,数位较短的数前面补零. 然后, 从最低位开始, 依次进行一次<mark>稳定排序</mark>（即高位相同的情况下不会打乱低位的排序结果）, 因为<strong>每个位可能的取值范围是固定的从0到9</strong>)。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。</li>
</ul>
</li>
</ol>
<h3 id="复杂度">复杂度</h3>
<img src="https://s1.ax1x.com/2020/03/15/83keCd.png" alt="十种排序算法复杂度" style="zoom:30%;" />
<h2 id="stack">Stack</h2>
<p>栈。前面的<a href="##Heap">堆</a>处介绍过了，这里不重复介绍了。</p>
<h2 id="string">String</h2>
<p>字符串。该分类比较杂，与字符串相关的题目都会汇总到这里来。</p>
<h2 id="topological-sort">Topological Sort</h2>
<p><a href="https://www.jianshu.com/p/3347f54a3187">拓扑排序</a>。</p>
<h2 id="tree">Tree</h2>
<p>树。这里的分类比较杂， 所以的树都放到这里来了。</p>
<ul>
<li>树的分类</li>
<li>典型方法</li>
<li>经典题型</li>
</ul>
<h2 id="two-pointers">Two Pointers</h2>
<p>双指针。主要用于遍历数组，两个指针指向不同的元素，从而协同完成任务。双指针可以从不同的方向向中间逼近也可以朝着同一个方向遍历。经典题目如：两数和、原地删除重复字符、原地翻转字符、回文串、链表是否有环等等。</p>
<h2 id="union-find">Union Find</h2>
<p><a href="https://blog.csdn.net/Yaokai_AssultMaster/article/details/78888846">并查集</a>。<strong>并查集</strong>是一种树型的数据结构，用于处理一些<a href="https://zh.wikipedia.org/wiki/%E4%B8%8D%E4%BA%A4%E9%9B%86">不交集</a>（Disjoint Sets）的合并及查询问题。</p>
<h2 id="unknow">Unknow</h2>
<p>未知。该分类下有超过200道题目，题型相比其他也许并不那么常规，但是他们中的绝大部分所采用的解法仍然是前面所有Tag中提到的算法。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[pytorch多GPU并行运算]]></title>
        <id>https://zxpzhong.github.io/post/pytorch-duo-gpu-bing-xing-yun-suan/</id>
        <link href="https://zxpzhong.github.io/post/pytorch-duo-gpu-bing-xing-yun-suan/">
        </link>
        <updated>2019-06-19T15:09:07.000Z</updated>
        <summary type="html"><![CDATA[<p>pytorch使用多块GPU并行运算</p>
]]></summary>
        <content type="html"><![CDATA[<p>pytorch使用多块GPU并行运算</p>
<!-- more --> 
<h1 id="pytorch多gpu运行">Pytorch多GPU运行</h1>
<ol>
<li>设置可用GPU环境变量。例如，使用0号和1号GPU'<br>
<code>os.environ[&quot;CUDA_VISIBLE_DEVICES&quot;] = '0,1'</code></li>
<li>设置模型参数放置到多个GPU上。在pytorch1.0之后的版本中，多GPU运行变得十分方便，先将模型的参数设置并行</li>
</ol>
<pre><code>        if torch.cuda.device_count() &gt; 1:
            print(&quot;Let's use&quot;, torch.cuda.device_count(), &quot;GPUs!&quot;)
            model = nn.DataParallel(model)
</code></pre>
<ol start="3">
<li>将模型参数设置使用GPU运行</li>
</ol>
<pre><code>        if torch.cuda.is_available():
            model.cuda()
</code></pre>
<h1 id="踩坑记录">踩坑记录</h1>
<ol>
<li>在训练中，需要使用验证集/测试集对目前的准确率进行测试，验证集/测试集的加载也会占用部分显存，所以在训练开始时，不要将所有显存都几乎占满，稍微留一些显存给训练过程中的测试环节</li>
<li>pytorch并行后，假设batchsize设置为64，表示每张并行使用的GPU都使用batchsize=64来计算（单张卡使用时，使用batchsize=64比较合适时，多张卡并行时，batchsize仍为64比较合适，而不是64*并行卡数）。</li>
</ol>
<h1 id="参考">参考</h1>
<ol>
<li><a href="https://www.zhihu.com/question/67726969">https://www.zhihu.com/question/67726969</a></li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[天池Docker提交]]></title>
        <id>https://zxpzhong.github.io/post/tian-chi-docker-ti-jiao/</id>
        <link href="https://zxpzhong.github.io/post/tian-chi-docker-ti-jiao/">
        </link>
        <updated>2019-06-19T15:07:49.000Z</updated>
        <summary type="html"><![CDATA[<p>天池竞赛提交如何提交Docker镜像？相信很多小伙伴容易倒在第一步上~~</p>
]]></summary>
        <content type="html"><![CDATA[<p>天池竞赛提交如何提交Docker镜像？相信很多小伙伴容易倒在第一步上~~</p>
<!-- more -->
<h1 id="天池竞赛简介">天池竞赛简介</h1>
<ul>
<li>天池大数据竞赛是由阿里巴巴集团主办，面向全球科研工作者的高端算法竞赛。通过开放海量数据和分布式计算资源，大赛让所有参与者有机会运用其设计的算法解决各类社会问题或业务问题。特别优秀的解决方案将有机会直接上线阿里巴巴旗下各电商网站（含淘宝、天猫等）或第三方合作伙伴平台，服务中国乃至世界数以亿计的用户。</li>
<li>这个竞赛在国内的地位可以比肩Kaggle，在竞赛中拿到好的成绩可以直接写上简历，加分还是很足的，具体优点我就不列举了，现在体会还那么深刻，但是前人的经验告诉我们，参加这个百利而无一害！！！！</li>
<li>B乎问答“参加天池对校招的作用”：<br>
<a href="https://www.zhihu.com/question/41449961" title="参加天池大数据竞赛对校园招聘有帮助吗？">https://www.zhihu.com/question/41449961</a></li>
</ul>
<h1 id="docker简介">Docker简介</h1>
<p>参加天池竞赛不可避免得要碰到一个问题，那就是最基本得提交赛题，本次我遇到的是通过提交<strong>阿里容器镜像服务</strong>的地址，竞赛刚看完题目后，第一遍提交应该是使用赛题提供的Demo文件提交，这样可以熟悉一遍赛题，熟悉提交流程。所以一定要先对Docker进行一个科普性了解。</p>
<h2 id="docker是什么">Docker是什么？</h2>
<ul>
<li>Docker是一个虚拟环境容器，可以将你的开发环境、代码、配置文件等一并打包到这个容器中，并发布和应用到任意平台中。比如，你在本地用Python开发网站后台，开发测试完成后，就可以将Python3及其依赖包、Flask及其各种插件、Mysql、Nginx等打包到一个容器中，然后部署到任意你想部署到的环境。<img src="https://s2.ax1x.com/2019/07/30/eGRf8e.png" alt="mark" loading="lazy"></li>
<li>大家从github上拉下来的代码，能直接运行么？往往不能，因为：</li>
<li>代码运行系统环境不同</li>
<li>数据集的文件夹路径不同</li>
<li>python依赖不同，可能你的环境中没装，可能你的版本过高或者过低</li>
<li>版本差别比较大的深度学习框架，有些函数有差异，是修改当前python的框架版本？还是新建虚拟环境重新装一个？</li>
<li>所以从github上拉下来的代码，多多少少还是要经过修改后才能正常运行，修改少的十分钟可以运行起来，多的需要一个小时以上，但是赛题方不可能帮你把你提交的代码全部修改后，然你的代码能够在赛题方的环境中运行，所以这种要求<strong>程序跨环境运行</strong>的要求就需要靠Docker来解决！！</li>
</ul>
<h2 id="docker基本概念">Docker基本概念</h2>
<p>说白了，Docker就是一个能够把你的运行环境也打包的容器，这样才能够让你的提交给赛题方的容器，可以不经过任何修改而直接运行，得出你的成绩。真正使用前还需要了解一些基本概念：镜像、容器、仓库。</p>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">打包后大小</th>
<th style="text-align:center">运行底层</th>
<th style="text-align:center">响应时间（包含修改）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">代码打包</td>
<td style="text-align:center">MB级别</td>
<td style="text-align:center">python+本机操作系统</td>
<td style="text-align:center">小时级别</td>
</tr>
<tr>
<td style="text-align:center">虚拟机</td>
<td style="text-align:center">10G级别</td>
<td style="text-align:center">虚拟化硬件+虚拟机</td>
<td style="text-align:center">开机5分钟</td>
</tr>
<tr>
<td style="text-align:center">Docker</td>
<td style="text-align:center">5G级别</td>
<td style="text-align:center">操作系统的Docker引擎</td>
<td style="text-align:center">秒级</td>
</tr>
</tbody>
</table>
<figure data-type="image" tabindex="1"><img src="https://s2.ax1x.com/2019/07/30/eGRhgH.png" alt="mark" loading="lazy"></figure>
<ol>
<li>Docker的gitbook地址，有时间的话建议还是把这个全部看完。<a href="https://yeasy.gitbooks.io/docker_practice/">https://yeasy.gitbooks.io/docker_practice/</a></li>
<li><strong>镜像</strong>：镜像就像面向对象程序中的类，镜像是静态的定义，镜像可以被修改，增删内容，但是镜像的运行必须通过生成容器实体</li>
<li><strong>容器</strong>：容器就像面向对象程序中的示例，容器是镜像运行时的实体，容器可以被创建、启动、停止、删除、暂停</li>
<li><strong>仓库</strong>：这个仓库就类似git仓库，但是git仓库是储存代码，而docker仓库是储存docker镜像
<ul>
<li><code>Docker Registry</code>：Docker Registry就像是一个仓库基地，里面可以有很多独立的仓库（Repository）</li>
<li><code>Repository</code>：每个仓库中只能存放一个镜像，同一镜像的不同版本（tag）都放在同一仓库中</li>
<li><code>tag</code>：仓库中镜像的标签（tag）就对应于镜像的版本，取名一般为0.0/2.4等</li>
<li><code>jwilder/nginx-proxy:2.03</code>：表示Docker Registry为jwilder，Repository为nginx-proxy，版本为2.03</li>
</ul>
</li>
</ol>
<h1 id="如何在天池中提交docker成功拿到自己的分数精炼版">如何在天池中提交Docker成功拿到自己的分数（精炼版）</h1>
<h2 id="本地准备好代码">本地准备好代码</h2>
<p>按照赛题方要求，写好python代码的输入输出，做好输入参数检查，这里推荐使用<code>argparse</code>，使用demo</p>
<pre><code class="language-python">import argparse
# 获取参数
parser = argparse.ArgumentParser()
parser.add_argument('--arg1', dest='arg1', type=str, default=None, help='接受--arg1=的参数为变量arg1，类型为str,缺省值为None，参数对应的帮助文档为help的内容')
args = parser.parse_args()
# 执行python **.py --arg1=SSS 后args.arg1的值为'SSS'
</code></pre>
<h2 id="编写requirementstxt">编写requirements.txt</h2>
<p>检查你的代码中所有的import,然后使用pip list查看你本地使用的版本，在同级目录中添加requirements.txt</p>
<pre><code>Pillow==5.3.0
tqdm==4.19.2
torchnet==0.0.4
</code></pre>
<h2 id="编写docker文件">编写Docker文件</h2>
<p>这一步其实是<strong>最难也是最关键的</strong>，但是我们是为了使用Docker而使用，所以这一步简化再简化，这里直接提供一个可以使用的制作cuda8.0+pytorch1.0.1镜像的Docker文件，使用该文件可以直接生成cuda8.0+pytorch1.0.1镜像</p>
<pre><code># Modify from source: https://hub.docker.com/r/nvidia/cuda
# This Docker build is 3.1G
# -----------------------------------------------------------------------------
FROM ubuntu:16.04
LABEL maintainer &quot;NVIDIA CORPORATION &lt;cudatools@nvidia.com&gt;&quot;

RUN apt-get update &amp;&amp; apt-get install -y --no-install-recommends ca-certificates apt-transport-https bzip2 gnupg-curl wget &amp;&amp; \
    rm -rf /var/lib/apt/lists/* &amp;&amp; \
    NVIDIA_GPGKEY_SUM=d1be581509378368edeec8c1eb2958702feedf3bc3d17011adbf24efacce4ab5 &amp;&amp; \
    NVIDIA_GPGKEY_FPR=ae09fe4bbd223a84b2ccfce3f60f4b3d7fa2af80 &amp;&amp; \
    apt-key adv --fetch-keys https://developer.download.nvidia.com/compute/cuda/repos/ubuntu1604/x86_64/7fa2af80.pub &amp;&amp; \
    apt-key adv --export --no-emit-version -a $NVIDIA_GPGKEY_FPR | tail -n +5 &gt; cudasign.pub &amp;&amp; \
    echo &quot;$NVIDIA_GPGKEY_SUM  cudasign.pub&quot; | sha256sum -c --strict - &amp;&amp; rm cudasign.pub &amp;&amp; \
    echo &quot;deb https://developer.download.nvidia.com/compute/cuda/repos/ubuntu1604/x86_64 /&quot; &gt; /etc/apt/sources.list.d/cuda.list


ENV CUDA_VERSION 8.0.61

ENV CUDA_PKG_VERSION 8-0=$CUDA_VERSION-1
RUN apt-get update &amp;&amp; apt-get install -y --no-install-recommends \
        cuda-nvrtc-$CUDA_PKG_VERSION \
        cuda-nvgraph-$CUDA_PKG_VERSION \
        cuda-cusolver-$CUDA_PKG_VERSION \
        cuda-cublas-8-0=8.0.61.2-1 \
        cuda-cufft-$CUDA_PKG_VERSION \
        cuda-curand-$CUDA_PKG_VERSION \
        cuda-cusparse-$CUDA_PKG_VERSION \
        cuda-npp-$CUDA_PKG_VERSION \
        cuda-cudart-$CUDA_PKG_VERSION &amp;&amp; \
    ln -s cuda-8.0 /usr/local/cuda &amp;&amp; \
    rm -rf /var/lib/apt/lists/*

# nvidia-docker 1.0
LABEL com.nvidia.volumes.needed=&quot;nvidia_driver&quot;
LABEL com.nvidia.cuda.version=&quot;${CUDA_VERSION}&quot;

RUN echo &quot;/usr/local/nvidia/lib&quot; &gt;&gt; /etc/ld.so.conf.d/nvidia.conf &amp;&amp; \
    echo &quot;/usr/local/nvidia/lib64&quot; &gt;&gt; /etc/ld.so.conf.d/nvidia.conf

ENV PATH /usr/local/nvidia/bin:/usr/local/cuda/bin:${PATH}
ENV LD_LIBRARY_PATH /usr/local/nvidia/lib:/usr/local/nvidia/lib64

# nvidia-container-runtime
ENV NVIDIA_VISIBLE_DEVICES all
ENV NVIDIA_DRIVER_CAPABILITIES compute,utility
ENV NVIDIA_REQUIRE_CUDA &quot;cuda&gt;=8.0&quot;
#-----------------------------------------------------------------------------


#MiniConda Install
RUN wget &quot;https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh&quot; &amp;&amp; \
    bash ./Miniconda3-latest-Linux-x86_64.sh* -b -p &amp;&amp; \
    rm Miniconda3* 
ENV PATH=&quot;/root/miniconda3/bin:${PATH}&quot;

#Add Requirement Packages 
RUN conda install pytorch torchvision cudatoolkit=8.0 -c pytorch &amp;&amp; \
    conda clean -all --yes
</code></pre>
<p>执行完成后，将对应的Docker镜像push到阿里云Docker镜像服务，这样相当于有了一个自己的cuda8+pythch镜像，在这个镜像的基础上，再进行后续操作</p>
<pre><code>#Above image
FROM $你的阿里镜像地址
LABEL maintainer &quot;容器名称&quot;
#设置工作目录
WORKDIR /competition
#添加工作目录下的所有文件
ADD [^p^u]* /competition/
</code></pre>
<h2 id="编写runsh文件">编写run.sh文件</h2>
<p>run.sh文件是docker运行的入口，所以你的python执行文件命令必须在run.sh中写完整，<code>$1</code>在脚本中表示脚本接收到的第一个参数（也相当于docker运行的第一个参数），我们需要把这个参数传递给python执行</p>
<pre><code>#!/bin/bash
#
# run.sh is the entry point of the submission.
# nvidia-docker run -v ${INPUT_DIR}:/input_images -v ${OUTPUT_DIR}:/output_data
#       -w /competition ${DOCKER_IMAGE_NAME} sh ./run.sh /input_images /output_data/result.csv
# where:
#   INPUT_DIR - directory with input png images
#   OUTPUT_FILE - the classification result for each image
#

INPUT_DIR=$1
OUTPUT_FILE=$2

python main.py \
  --input_dir=&quot;${INPUT_DIR}&quot; \
  --output_file=&quot;${OUTPUT_FILE}&quot; \
</code></pre>
<h2 id="拉取官方私有docker基础镜像并且制作自己的镜像">拉取官方/私有Docker基础镜像，并且制作自己的镜像</h2>
<p>做好上述工作后，使用命令<code>sudo docker build -t $docker_name .</code>制作新的docker镜像，这时系统会拉取Docker文件中FROM地址对应的镜像，并且执行后续的修改，并且将其打包成新的镜像，镜像名称为<code>$docker_name</code>，</p>
<h2 id="自己的镜像添加改名版本号">自己的镜像添加改名版本号</h2>
<p>使用<code>sudo docker images</code>查看刚才自己制作的docker的$ID，并且使用如下命令对docker重命名，为后续的push设置仓库地址和版本号<br>
<code>sudo docker tag $ID registry.cn-shenzhen.aliyuncs.com/$你的阿里容器仓库地址:$版本号</code></p>
<h2 id="push自己的镜像">Push自己的镜像</h2>
<p>使用如下命令push自己的本地镜像到阿里云<br>
<code>sudo docker push registry.cn-shenzhen.aliyuncs.com/felix1/$你的阿里容器仓库地址:$版本号</code><br>
执行完毕后，可以在自己镜像仓库的镜像版本中看到自己推送的镜像，即完成了整个Docker的制作与推送</p>
<h1 id="感想">感想</h1>
<p>这也是我本人第一次用Docker，感觉Docker是在纯代码和虚拟机之间的一种折衷，既想方设法得保证所有环境都可以正常迁移到新的环境，又相比于虚拟机减少冗余部分，而只保留了程序运行所必须的部分，而且实测，新制作的Docker拉取到一台陌生的机器上时，可以完美直接运行，性能也基本没有下降，而且支持Docker直接使用本机显卡，这对深度学习使用Docker简直是福音。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ncnn c++模型测试]]></title>
        <id>https://zxpzhong.github.io/post/ncnn-cmo-xing-ce-shi/</id>
        <link href="https://zxpzhong.github.io/post/ncnn-cmo-xing-ce-shi/">
        </link>
        <updated>2019-06-19T15:06:41.000Z</updated>
        <summary type="html"><![CDATA[<p>ncnn模型c++代码测试</p>
]]></summary>
        <content type="html"><![CDATA[<p>ncnn模型c++代码测试</p>
<!-- more -->
<h1 id="ncnn-c测试">ncnn c++测试</h1>
<p>在模型转换完成后，紧接着就要真正在移动端上运行啦，不过在正式放到嵌入式设备上运行时（这一步也不属于我做），还是在PC上拿c++测试一下，确认没问题了才能说明模型的正确性</p>
<h1 id="ncnn安装">ncnn安装</h1>
<p>先使用git命令拉取ncnn源码</p>
<pre><code>git clone https://github.com/Tencent/ncnn
</code></pre>
<p>对ncnn进行编译、安装</p>
<pre><code>cd ncnn
mkdir build &amp;&amp; cd build
cmake ..
make -j
make install
</code></pre>
<p>执行完毕后，在$ncnn_dir/build/install/文件夹下会产生安装文件</p>
<ul>
<li>$ncnn_dir/build/install/lib/libncnn.a为链接库</li>
<li>$ncnn_dir/build/install/include/为头文件包含路径</li>
</ul>
<h1 id="cmake配置工程">Cmake配置工程</h1>
<p>在CMakeLists.txt中，加入如下代码，来添加ncnn的链接库和头文件路径</p>
<pre><code># 设置ncnn的链接库和头文件路径
include_directories($ncnn_dir/build/install/include/)
target_link_libraries($ncnn_dir/build/install/lib/libncnn.a)
</code></pre>
<p>由于本人模型输入为图片，因此还需要配置OpenCV,这里就不啰嗦了，直接参考如下链接安装：</p>
<p>Ubuntu16.04安装opencv for c++：<a href="https://blog.csdn.net/qq_33591712/article/details/83279982">https://blog.csdn.net/qq_33591712/article/details/83279982</a></p>
<p>其他Cmake基本配置，比如工程名、增加需要输出的可执行文件、链接OpenCV等等，在这里就不啰嗦了，参考如下链接<br>
<a href="https://www.cnblogs.com/lidabo/p/7359422.html">https://www.cnblogs.com/lidabo/p/7359422.html</a></p>
<h1 id="ncnn模型文件netparamsnetbin文件解析">ncnn模型文件net.params,net.bin文件解析</h1>
<ol>
<li>params包含了网络结构</li>
<li>bin包含了网络参数</li>
<li>对于使用该模型，最重要的是从这个网络结构中找到你要的输入输出节点名称，下面是一个网络结构的例子</li>
</ol>
<pre><code>7767517
60 63
Input            data             0 1 data 0=3 1=180 2=550
Convolution      ConvNd_1         1 1 data ConvNd_1 0=32 1=3 2=1 3=2 4=1 5=0 6=864
........................
....... 中间省略.........
........................
Dropout          Dropout_2        1 1 Addmm_1 Dropout_2
InnerProduct     Addmm_2          1 1 Dropout_2 Addmm_2 0=130 1=1 2=33280
Softmax          Softmax_1        1 1 Addmm_2 Softmax_1 0=0
</code></pre>
<ul>
<li>其中第一行的7767517是ncnn magic numger(幻数)，</li>
<li>第二行的60 63。60为layer number（网络层数），63为blob number（参数块数）</li>
<li>剩余的为Input            data             0 1 data 0=3 1=180 2=550，我们只关心中间的<code>data</code>,<code>Softmax_1</code>等，这是网络的节点名称，不论是输入还是输出节点，都必须在代码中指定输入输出节点名称</li>
</ul>
<h1 id="c代码">C++代码</h1>
<ol>
<li>包含ncnn头文件</li>
</ol>
<pre><code>#include &quot;net.h&quot;
</code></pre>
<ol start="2">
<li>读取输入图片</li>
</ol>
<pre><code>string img_path = &quot;$IMG_PATH&quot;;
cv::Mat img = cv::imread(img_path, CV_LOAD_IMAGE_COLOR);
cv::Mat img2;
//这里一定要检查你图片的大小和训练网络时的图片输入大小，要一样，否则到全连接层时会出现矩阵维数无法相乘
//input_width：网络输入图片宽度
//input_height：网络输入图片高度
cv::resize(img, img2, cv::Size(input_width, input_height));
</code></pre>
<ol start="3">
<li>加载ncnn模型和参数</li>
</ol>
<pre><code>// 加载模型和参数
ncnn::Net DeepNet;
DeepNet.load_param(&quot;$param_path&quot;);
DeepNet.load_model(&quot;$bin_path&quot;);
</code></pre>
<ol start="4">
<li>将读取的输入图片转化为ncnn::Mat input数据类型，通过ncnn自带的从图像像素转换函数</li>
</ol>
<pre><code>ncnn::Mat input = ncnn::Mat::from_pixels(img2.data, ncnn::Mat::PIXEL_BGR, img2.cols, img2.rows);
</code></pre>
<ol start="5">
<li>经输入Mat送入网络并定义输出节点获取结果</li>
</ol>
<pre><code>ncnn::Extractor extractor = DeepNet.create_extractor();
//    将'data'节点名称和ncnn::Mat input对应起来
extractor.input(&quot;data&quot;, input);
//    将'Addmm_1'节点名称和ncnn::Mat output对应起来
ncnn::Mat output;
extractor.extract(&quot;Addmm_1&quot;, output);
</code></pre>
<ol start="6">
<li>将ncnn::Mat类型的输出结果转化为std::vector<float></li>
</ol>
<pre><code>std::vector&lt;float&gt; &amp; cls_scores
//    网络输出为output,将output转化到cls_scores中输出
cls_scores.resize(output.cstep);
for(int j=0; j&lt;output.cstep; j++)
{
    const float* prob = (float*)output.data + output.c * j;
    cls_scores[j] = prob[0];
}
//Debug打印输出
for(int j = 0;j &lt; cls_scores.size();j++)
{
    cout &lt;&lt; cls_scores[j] ;
}
</code></pre>
<h1 id="调试trick">调试trick</h1>
<ol>
<li>对于输出节点，可以使用如下代码来打印节点的通道数和长宽，来判断该节点是否为你需要的那个输出节点（比如你要的输出为1<em>512</em>1,那么你可以根据你自己的网络结构大概定位到哪部分，然后挨个使用这种方法打印输出，观察输出节点的维度来判断是否为你需要的输出节点）</li>
</ol>
<pre><code>    cout &lt;&lt; &quot;output.c: &quot; &lt;&lt; output.c &lt;&lt; endl;
    cout &lt;&lt; &quot;output.w: &quot; &lt;&lt; output.w &lt;&lt; endl;
    cout &lt;&lt; &quot;output.h: &quot; &lt;&lt; output.h &lt;&lt; endl;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[win10使用RabbitMQ实现消息队列]]></title>
        <id>https://zxpzhong.github.io/post/win10-shi-yong-rabbitmq-shi-xian-xiao-xi-dui-lie/</id>
        <link href="https://zxpzhong.github.io/post/win10-shi-yong-rabbitmq-shi-xian-xiao-xi-dui-lie/">
        </link>
        <updated>2019-06-19T15:05:16.000Z</updated>
        <summary type="html"><![CDATA[<p>熟悉了linux下使用消息队列实现进程异步，转到win10下该怎么办？</p>
]]></summary>
        <content type="html"><![CDATA[<p>熟悉了linux下使用消息队列实现进程异步，转到win10下该怎么办？</p>
<!-- more -->
<h1 id="第三方消息队列服务rabbitmq">第三方消息队列服务RabbitMQ</h1>
<h2 id="rabbitmq简介">RabbitMQ简介</h2>
<ol>
<li>可靠性（Reliability）:RabbitMQ 使用一些机制来保证可靠性，如持久化、传输确认、发布确认。</li>
<li>灵活的路由（Flexible Routing）:在消息进入队列之前，通过 Exchange 来路由消息的。对于典型的路由功能，RabbitMQ 已经提供了一些内置的 Exchange 来实现。针对更复杂的路由功能，可以将多个 Exchange 绑定在一起，也通过插件机制实现自己的 Exchange 。</li>
<li>消息集群（Clustering）:多个 RabbitMQ 服务器可以组成一个集群，形成一个逻辑 Broker 。</li>
<li>高可用（Highly Available Queues）:队列可以在集群中的机器上进行镜像，使得在部分节点出问题的情况下队列仍然可用。</li>
<li>多种协议（Multi-protocol）:RabbitMQ 支持多种消息队列协议，比如 STOMP、MQTT 等等。</li>
<li>多语言客户端（Many Clients）:RabbitMQ 几乎支持所有常用语言，比如 Java、.NET、Ruby 等等。</li>
<li>管理界面（Management UI）:RabbitMQ 提供了一个易用的用户界面，使得用户可以监控和管理消息 Broker 的许多方面。</li>
<li>跟踪机制（Tracing）:如果消息异常，RabbitMQ 提供了消息跟踪机制，使用者可以找出发生了什么。</li>
<li>插件机制（Plugin System）:RabbitMQ 提供了许多插件，来从多方面进行扩展，也可以编写自己的插件。</li>
</ol>
<h2 id="rabbitmq-server安装">RabbitMQ  server安装</h2>
<ol>
<li>RabbitMQ服务端代码是使用并发式语言Erlang，所以先安装Erlang
<ul>
<li>Erlang官网<a href="http://www.erlang.org/downloads">http://www.erlang.org/downloads</a>，下载对应版本后，安装<br>
<img src="https://s2.ax1x.com/2019/07/30/eGDgqU.png" alt="mark" loading="lazy"></li>
<li>安装位置任意，安装过程中会自动把安装位置的bin目录加入PATH环境变量</li>
</ul>
</li>
<li>官网<a href="http://www.rabbitmq.com/">http://www.rabbitmq.com/</a>，下载对应的安装文件exe，安装<br>
<img src="https://s2.ax1x.com/2019/07/30/eGBw1x.png" alt="mark" loading="lazy"></li>
<li>进入安装目录的sbin目录<br>
<img src="https://s2.ax1x.com/2019/07/30/eGB0c6.png" alt="mark" loading="lazy"></li>
<li>输入<code>rabbitmq-plugins enable rabbitmq_management</code>安装rabbitmq对应的web管理界面</li>
<li>rabbitmq安装后会在操作系统中注册为系统服务，并且自动启动。在浏览器中输入<a href="http://127.0.0.1:15672">http://127.0.0.1:15672</a>,如果正确显示rabbitmq的web界面，则安装正确<br>
<img src="https://s2.ax1x.com/2019/07/30/eGBBjK.png" alt="mark" loading="lazy"></li>
</ol>
<h2 id="rabbitmq-c安装">RabbitMQ-c安装</h2>
<ol>
<li>环境：
<ul>
<li>PC：win10 64位</li>
<li>VS版本：VS2015 msvc14 64bit编译器</li>
<li>RabbitMQ-c版本：v0.9.0</li>
</ul>
</li>
<li>拉取RabbitMQ-c源码：<code>git clone https://github.com/alanxz/rabbitmq-c.git</code></li>
<li>进入RabbitMQ-c目录<code>cd $RabbitMQ-c_PATH/</code>，创建build文件夹<code>mkdir build</code></li>
<li>打开cmake-gui，设置src与build目录为<code>$RabbitMQ-c_PATH/</code>和<code>$RabbitMQ-c_PATH/build</code></li>
<li>编译器选择msvc2014 64bit，如果没有弹出让你选择编译器，则可以点击file-&gt;delete cache来删除缓存，重新选择编译器<br>
<img src="https://s2.ax1x.com/2019/07/30/eGBrnO.png" alt="mark" loading="lazy"></li>
<li>取消勾选ENABLE_SSL_SUPPORT,依次按下configure-&gt;generate-&gt;open project，在VS2015中打开项目<br>
<img src="https://s2.ax1x.com/2019/07/30/eGByHe.png" alt="mark" loading="lazy"></li>
<li>VS中设置64bit release版本<br>
<img src="https://s2.ax1x.com/2019/07/30/eGBgNd.png" alt="mark" loading="lazy"></li>
<li>生成解决方案<br>
<img src="https://s2.ax1x.com/2019/07/30/eGDEgx.png" alt="mark" loading="lazy"></li>
<li>在对应目录下生成库文件<br>
<img src="https://s2.ax1x.com/2019/07/30/eGDNqS.png" alt="mark" loading="lazy"></li>
</ol>
<h2 id="rabbitmq-c封装库simpleamqpclient安装">RabbitMQ-c封装库SimpleAmqpClient安装</h2>
<ol>
<li>安装boost
<ul>
<li><strong>注意，一定要安装二进制安装文件，不要下载源码自己编译</strong>,自己编译可能出现很多问题</li>
<li>下载地址<a href="https://sourceforge.net/projects/boost/files/boost-binaries/">https://sourceforge.net/projects/boost/files/boost-binaries/</a></li>
<li>安装后，include路径为<img src="https://s2.ax1x.com/2019/07/30/eGDdaQ.png" alt="mark" loading="lazy">，lib路径为<img src="https://s2.ax1x.com/2019/07/30/eGDw5j.png" alt="mark" loading="lazy"></li>
</ul>
</li>
<li>安装doxygen（这一步是为了生成API Document，可以不做）
<ul>
<li>下载地址<a href="http://www.doxygen.nl/download.html">http://www.doxygen.nl/download.html</a></li>
<li><img src="https://s2.ax1x.com/2019/07/30/eGDBPs.png" alt="mark" loading="lazy">直接下载对应的安装文件，安装后会自动加入PATH环境变量</li>
</ul>
</li>
<li>git拉取SimpleAmqpClient源码,在SimpleAmqpClient源码下创建build目录</li>
<li>cmake设置src目录和build目录</li>
<li>取消ENABLE_SSL_SUPPORT，手动添加Boost_USE_STATIC_LIBS二进制类型<br>
<img src="https://s2.ax1x.com/2019/07/30/eGDDGn.png" alt="mark" loading="lazy"></li>
<li>手动添加BOOST_ROOT，填入BOOST的安装根目录；手动添加BOOST_LIBRARY，填入BOOST库目录</li>
<li>手动添加Rabbitmqc_INCLUDE_DIR,填入Rabbitmqc的头文件路径，手动添加Rabbitmqc_LIBRARY,填入Rabbitmqc的库路径</li>
<li>取消勾选ENABLE_SSL_SUPPORT,依次按下configure-&gt;generate-&gt;open project，在VS2015中打开项目</li>
<li>VS中设置64bit release版本</li>
<li>在项目属性中添加Rabbitmqc的头文件路径、boost头文件路径，Rabbitmqc的库路径、boost库路径，和对应的lib名称</li>
<li>右键点击项目中的SimpleAmqpClient，点击重新生成，编译成功后，会在build/release目录下生成对应的库<br>
<img src="https://s2.ax1x.com/2019/07/30/eGDsx0.png" alt="mark" loading="lazy"></li>
</ol>
<h2 id="simpleamqpclient-demo测试">SimpleAmqpClient   Demo测试</h2>
<ul>
<li>VS中新建项目</li>
<li>添加<strong>Rabbitmqc</strong>的头文件和库文件；添加<strong>boost</strong>的头文件和库文件；添加<strong>SimpleAmqpClient</strong>的头文件和库文件（怎么添加不详述了）</li>
<li>分别编译下列两个程序，执行后，可以在Send.cpp对应的console中输入任意字符，回车，在Recv.cpp对应的console中可以接收到输入，同时在Rabbitmq的web管理界面可以看到有两个连接接入，并且消息队列的数据流情况都可以看到</li>
</ul>
<p>Send.cpp</p>
<pre><code>#include &lt;SimpleAmqpClient/SimpleAmqpClient.h&gt;
#include &lt;iostream&gt;
int main() {
  std::string queue_name = &quot;hello&quot;;

  AmqpClient::Channel::ptr_t channel = AmqpClient::Channel::Create(&quot;localhost&quot;);
  //创建channel

  channel-&gt;DeclareQueue(queue_name, false, true, false, false);
  //创建队列，第一个参数为队列名称，其余后续会提到。

  std::string message;
  std::cin &gt;&gt; message;

  channel-&gt;BasicPublish(&quot;&quot;, queue_name,
                        AmqpClient::BasicMessage::Create(message));
  //第一个是exchange名称，第二个参数是routing_key（此处可理解为消息会被送往的队列）。

  qDebug() &lt;&lt; &quot;[x] send &quot; &lt;&lt; QString::fromStdString(message);
}
</code></pre>
<p>Recv.cpp</p>
<pre><code>#include &lt;SimpleAmqpClient/SimpleAmqpClient.h&gt;
#include &lt;iostream&gt;

int main() {
  std::string queue_name = &quot;hello&quot;;

  AmqpClient::Channel::ptr_t channel = AmqpClient::Channel::Create(&quot;localhost&quot;);

  channel-&gt;DeclareQueue(queue_name, false, true, false, false);

  std::string consumer_tag = channel-&gt;BasicConsume(queue_name, &quot;&quot;);
  //第二个参数为消费者名称，返回值也是消费者名称。

  while (1) {

    qDebug() &lt;&lt; &quot;[y] receve &quot; &lt;&lt; QString::fromStdString(buffer);

    AmqpClient::Envelope::ptr_t envelope =
        channel-&gt;BasicConsumeMessage(consumer_tag);

    std::string buffer = envelope-&gt;Message()-&gt;Body();
    //消息放在信封里，需要解析

    std::cout &lt;&lt; &quot;[y] receve &quot; &lt;&lt; buffer &lt;&lt; std::endl;
  }

  channel-&gt;BasicCancel(consumer_tag);
  //关闭消费者。
}
</code></pre>
<h1 id="参考博文">参考博文</h1>
<ul>
<li><a href="https://blog.csdn.net/lixiang987654321/article/details/81155299">https://blog.csdn.net/lixiang987654321/article/details/81155299</a></li>
<li><a href="https://blog.csdn.net/weixin_39735923/article/details/79288578">https://blog.csdn.net/weixin_39735923/article/details/79288578</a></li>
<li><a href="https://www.zhihu.com/question/20428371">https://www.zhihu.com/question/20428371</a></li>
<li><a href="https://blog.csdn.net/csm201314/article/category/7023771">https://blog.csdn.net/csm201314/article/category/7023771</a></li>
<li><a href="https://www.jianshu.com/p/79ca08116d57">https://www.jianshu.com/p/79ca08116d57</a></li>
</ul>
<h1 id="踩坑记录">踩坑记录</h1>
<ol>
<li>VS生成库时，提示找不到定义接入点，这是因为没有main函数，不是生成exe而是生成库<a href="https://blog.csdn.net/wushao126/article/details/51785505">https://blog.csdn.net/wushao126/article/details/51785505</a></li>
<li>在win10上编译第三方库时，可以采用CMake配置生成sln对应的文件，然后用VS打开sln进行编译</li>
<li>opencv3.0 &quot;ACCESS_MASK&quot; ambiguous symbol<a href="https://blog.csdn.net/xu20082100226/article/details/45482387">https://blog.csdn.net/xu20082100226/article/details/45482387</a></li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[win10下VS+QT混合编程]]></title>
        <id>https://zxpzhong.github.io/post/win10-xia-vsqt-hun-he-bian-cheng/</id>
        <link href="https://zxpzhong.github.io/post/win10-xia-vsqt-hun-he-bian-cheng/">
        </link>
        <updated>2019-06-19T15:01:04.000Z</updated>
        <summary type="html"><![CDATA[<p>厌倦了windows系统API？但是又没脱离VS进行环境配置？何不试试windows下的VS+QT混合编程</p>
]]></summary>
        <content type="html"><![CDATA[<p>厌倦了windows系统API？但是又没脱离VS进行环境配置？何不试试windows下的VS+QT混合编程</p>
<!-- more --> 
<h1 id="visiual-studio与qt对比">Visiual Studio与QT对比</h1>
<h2 id="win10下vs进行c编程的痛点">Win10下VS进行c++编程的痛点</h2>
<ul>
<li>功能没有整合，变量名、类名都贼长（是见名知义了，但是每次看都要半天，而且这么长的变名字导致程序密集，看的眼疼）</li>
<li>总是需要大段大段复制粘贴（为什么不把一大段功能整合？）</li>
<li>MFC界面功能完善但是外观老套布局难（相比之下QtCreator就好很多，这也是QtCreator+QT类库用来做界面程序最大的优势了）</li>
</ul>
<h2 id="qt的优点">QT的优点</h2>
<ul>
<li>功能集成度高、功能分类明确、编程时逻辑清晰</li>
<li>跨平台，在linux和win下基本不用考虑操作系统差异</li>
</ul>
<h2 id="qt的缺点">QT的缺点</h2>
<ul>
<li>环境配置远远不如Visual Studio，QtCreator配置环境全部放到.pro文件中，默认使用qmake配置工程，而不是cmake，原意应该是想更加简化cmake适应qt的环境，但是明明在qmake配置过（不论是头文件还是库文件），但是重新构建就是不管用，无解</li>
<li>编译时，常常出现symbol not found错误，一个简单的程序，又没有用到自己外部的库，却老是出现这种莫名其妙的错误</li>
<li>我的熟练的Ctrl+Z技能应该就是大二那会用QT练起来的，明明只是简单的加了几个回车，编译后缺出现symbol not found错误，赶紧回退回退，有时候万一不小心存盘了又找不到旧版，出现symbol not found后然后就完全没办法让程序通过编译，然后又要新建工程，然后把文件都拷贝过来，改来改去</li>
</ul>
<h1 id="vsqt取长补短">VS+QT取长补短</h1>
<p>上面说到了，VS在win下做c++开发天下无敌的有点就是完全可视化的环境配置，所有的头文件、库等等配置全部通过工程的属性中可以设置，相比于Qt Creator为了满足跨平台的需求，必须通过qmake文件（cmake也一样）配置，这种手动输入的方法，对于非常熟练、经验十足的大佬来说没有问题，但是对于一般人来说，要了解所有的qmake中特殊变量名比直接鼠标点点难得多，而且在windows下运行的程序，依赖的环境变量、还有很多我也不知道的东西，感觉比linux下多很多，如果全部都通过手敲代码的形式配置，又麻烦又难记。<br>
所以<strong>综合这两者的优缺点</strong>，采用VS作为IDE用来配置工程依赖+QT类库进行开发，这种方法可行，很大程度上是自称宇宙第一无敌IDE Visual Stidio的功劳，完美得QT插件使得Qt、QtCreator等都可以完美集成到VS中来做（人家QT并不想鸟你而你却强行把人家包含进来干什么！），事实正面，VS在这方面做的确实很好，试了下，基本上不费事，可以完美在VS中开发QT，而且再也不用管qmake文件得编辑了</p>
<h1 id="vsqt安装">VS+QT安装</h1>
<h2 id="qt安装">QT安装</h2>
<ul>
<li>qt版本：5.9.3</li>
<li>下载地址：http://download.qt.io/archive/qt/5.9/5.9.3/</li>
<li>安装注意事项，编译器一定要选择msvc2015-64bit选项，其他可以都不用选择（msvc是win下专用的c++编译器，微软出品；工业相机的SDK程序出厂测试编译器是msvc；VS对msvc的支持性最好）</li>
</ul>
<h2 id="vs安装">VS安装</h2>
<ul>
<li>VS版本：2015 专业版</li>
<li>下载地址：http://download.microsoft.com/download/B/8/9/B898E46E-CBAE-4045-A8E2-2D33DD36F3C4/vs2015.pro_chs.iso</li>
<li>该版本是官方的专业版，不用担心中毒什么的，激活密钥：HMGNV-WCYXV-X7G9W-YCX63-B98R2</li>
<li>安装过程中，选择编译器为msvc2015-x64、msvc2015-x86、MFC支持（以防万一要用）</li>
</ul>
<h2 id="qt与vs完美融合">QT与VS完美融合</h2>
<p>教程地址：<a href="https://blog.csdn.net/yzy_1996/article/details/81939610">https://blog.csdn.net/yzy_1996/article/details/81939610</a></p>
<h2 id="opencv安装">OPENCV安装</h2>
<ul>
<li>opencv版本：3.2</li>
<li>下载地址：https://sourceforge.net/projects/opencvlibrary/files/opencv-win/3.2.0/opencv-3.2.0-vc14.exe/download</li>
<li>不需要安装网上的编译，直接下载opencv win的编译好的包，直接解压后</li>
<li>lib路径：$OPENCV_DIR/build/x64/vc14/lib/opencv_world320.lib</li>
<li>include路径：$OPENCV_DIR/build/include/</li>
</ul>
<h2 id="大恒相机sdk安装">大恒相机SDK安装</h2>
<ul>
<li>版本：V18.06.25.01</li>
<li>下载地址：http://gb.daheng-imaging.com/CN/Software/Cameras/Windows/Galaxy_V18.06.25.01_X86_Win_cn.zip</li>
<li>lib路径：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mi>D</mi><msub><mi>K</mi><mi>D</mi></msub><mi>I</mi><mi>R</mi><mi mathvariant="normal">/</mi><mi>S</mi><mi>a</mi><mi>m</mi><mi>p</mi><mi>l</mi><mi>e</mi><mi>s</mi><mi mathvariant="normal">/</mi><mi>C</mi><mo>+</mo><mo>+</mo><mi>S</mi><mi>D</mi><mi>K</mi><mi mathvariant="normal">/</mi><mi>l</mi><mi>i</mi><mi>b</mi><mi mathvariant="normal">/</mi><mi>x</mi><mn>64</mn><mi mathvariant="normal">/</mi><mo separator="true">;</mo></mrow><annotation encoding="application/x-tex">SDK_DIR/Samples/C++ SDK/lib/x64/;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">D</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">a</span><span class="mord mathdefault">m</span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">+</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">i</span><span class="mord mathdefault">b</span><span class="mord">/</span><span class="mord mathdefault">x</span><span class="mord">6</span><span class="mord">4</span><span class="mord">/</span><span class="mpunct">;</span></span></span></span>SDK_DIR/Samples/VC SDK/lib/x64/;</li>
<li>include路径：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mi>D</mi><msub><mi>K</mi><mi>D</mi></msub><mi>I</mi><mi>R</mi><mi mathvariant="normal">/</mi><mi>S</mi><mi>a</mi><mi>m</mi><mi>p</mi><mi>l</mi><mi>e</mi><mi>s</mi><mi mathvariant="normal">/</mi><mi>C</mi><mo>+</mo><mo>+</mo><mi>S</mi><mi>D</mi><mi>K</mi><mi mathvariant="normal">/</mi><mi>i</mi><mi>n</mi><mi>c</mi><mi mathvariant="normal">/</mi><mo separator="true">;</mo></mrow><annotation encoding="application/x-tex">SDK_DIR/Samples/C++ SDK/inc/;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">D</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">a</span><span class="mord mathdefault">m</span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">+</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mord">/</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">c</span><span class="mord">/</span><span class="mpunct">;</span></span></span></span>SDK_DIR/Samples/VC SDK/inc/;</li>
</ul>
<h1 id="采坑记录">采坑记录</h1>
<h2 id="无法解析的外部符号-winmain">无法解析的外部符号 WinMain</h2>
<p>这是因为windows应用程序分为两种，一种是console（控制台），另一种是windwos（窗口），QT相对于VS的分类属于console，需要将项目/属性/链接器/子系统一栏设置为：(/SUBSYSTEM:CONSOLE)，如果设置为(/SUBSYSTEM:WINDOWS)则会找不到WinMain符号</p>
<h2 id="stdafxh-not-found">stdafx.h not found</h2>
<p>将程序中的这一句话注释，然后将项目/属性/c/c++/预编译头/预编译头一栏修改为不使用预编译头</p>
<h2 id="include-qlabel-qlabel-not-found">#include &quot;QLabel&quot; QLabel not found</h2>
<p>这是因为Qt5.9.3中，将QT加入VS后，默认只添加了<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;EOF&#039;, got &#039;#&#039; at position 78: …gets路径下，因此要改为使用#̲include &quot;QtWidg…'>QT_DIR/msvc2015_64/include/为include路径，但是QLabel文件再include/QtWidgets路径下，因此要改为使用#include &quot;QtWidgets/QLabel&quot;，或者手动将</span>QT_DIR/msvc2015_64/include/QtWidgets添加到include路径中</p>
]]></content>
    </entry>
</feed>