<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://zxpzhong.github.io/</id>
    <title>Felix计算机视觉小屋</title>
    <updated>2020-03-15T14:50:29.497Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://zxpzhong.github.io/"/>
    <link rel="self" href="https://zxpzhong.github.io/atom.xml"/>
    <subtitle>念念不忘必有回响：&lt;a href=&quot;https://github.com/zxpzhong&quot; target=&quot;_blank&quot;&gt;我的github&lt;/a&gt;;&lt;a href=&quot;http://aicv.club/&quot; target=&quot;_blank&quot;&gt;我的博客&lt;/a&gt;</subtitle>
    <logo>https://zxpzhong.github.io/images/avatar.png</logo>
    <icon>https://zxpzhong.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Felix计算机视觉小屋</rights>
    <entry>
        <title type="html"><![CDATA[LRU+递归实现暴力解题]]></title>
        <id>https://zxpzhong.github.io/post/LRU+递归实现暴力解题</id>
        <link href="https://zxpzhong.github.io/post/LRU+递归实现暴力解题">
        </link>
        <updated>2020-03-15T10:05:41.000Z</updated>
        <summary type="html"><![CDATA[<p>LRU+递归实现暴力解题</p>
]]></summary>
        <content type="html"><![CDATA[<p>LRU+递归实现暴力解题</p>
<!-- more -->
<h1 id="lru递归实现暴力解题">LRU+递归实现暴力解题</h1>
<h2 id="递归">递归</h2>
<p>递归是一种将问题串行分解为多个完全相同的子问题的方法，递归方法的流程如下：</p>
<ol>
<li>分析整个问题能否分解为多个完全一样的的<mark>串行解决</mark>的子问题（能否递归）</li>
<li>每个串行解决的子问题如何<mark>递归</mark>得到下一个串行解决的子问题（子问题分解）</li>
<li>初始条件和终止条件，结果的汇总一般使用全局变量接收（初始条件和终止条件）</li>
</ol>
<p>但是如果简单只用递归，会造成大量的重复计算。比如Leetcode第91题，”解码方法“中：</p>
<img src="https://s1.ax1x.com/2020/03/15/83WtYR.png" alt="Leetcode 91题" style="zoom:38%;" />
<p>将一个数字字符串解码为A到Z的英文单词。由于解码时，需要考虑”12“是”1“+”2“，得到”AB“；还是”12“，得到”L“，所以后续有很多情况。这题的最优解是采用<mark>动态规划</mark>，为了防止误导大家，我先把这题的一个较好的题解放出来：</p>
<pre><code class="language-python">class Solution(object):
	def numDecodings(self, s):
		length = len(s)
		# 上次结果
		pre = 1
		# 当前结果
		cur = 1
		if s[0] == '0':
			return 0
		ans = 0
		for i in range(1,length):
			temp = cur * (1 if not s[i] == '0' else 0) + pre * (1 if 9&lt;int(s[i-1:i+1]) &lt;= 26 else 0)
			pre = cur
			cur = temp
		return cur
</code></pre>
<p>应用上面的递归思路，将解码一整个字符串分解为多个串行执行的相同子任务，即每次针对输入的字符串，只解码第一个可以正确解码字符组（'1'~'26'），然后递归继续解码，每次递归到剩余字符长度为0，则说明解码方法多出一种，对结果变量进行累加即可。代码如下：</p>
<pre><code class="language-python">class Solution(object):
    def numDecodings(self, s):
        return self.split_one(s)
    def split_one(self,cur_str):
        length = len(cur_str)
        ans = 0
        if length == 0:
            # 分解完毕
            return 1
        if not cur_str[0] == '0':
            ans+=self.split_one(cur_str[1:])
            if length &gt;= 2 and int(cur_str[:2]) &lt;= 26:
                # 两位也可以拿出来解释
                ans+=self.split_one(cur_str[2:])
        return ans
</code></pre>
<p>当然这样是超时了：</p>
<img src="https://s1.ax1x.com/2020/03/15/83oKp9.png" alt="递归超时" style="zoom:50%;" />
<h2 id="递归超时的原因">递归超时的原因</h2>
<p>一般而言对于题目最暴力的解法是穷举所有的可能，递归就是穷举法的一种相对还比较优雅的实现，没有改进或者剪枝的递归和暴力穷举的复杂度是相同的。递归超时的主要原因在于：算法经过不同路径到达同一个状态后，虽然这是同一个状态且后续路径即使完全相同，这也算是完全不同的两种解法，后续的路径会被反复重复计算。</p>
<p>比如上题中，对于字符串”1121“，如果使用暴力解法穷举，则：</p>
<pre><code class="language-python">'1'	-&gt; '1'	-&gt; '2'	-&gt; '1'
						-&gt; '21'
		-&gt; '12'	-&gt; '1'
'11'-&gt; '2'	-&gt; '1'
		-&gt; '21'
</code></pre>
<p>对于上述第一行和第四行中，使用'1'+'1'和使用'11'后，剩余字符都是'21'，也就是通过不同路径到达同一状态，但是暴力递归对于后续相同的'21'分解，完全重复了两遍运算，并且随着问题的输入规模增大，重复计算量将非常的大，导致程序运行超时。</p>
<h2 id="利用lru减少递归中的重复计算">利用LRU减少递归中的重复计算</h2>
<p>根据上面的分析，我们找到了重复计算的根源，并且某个子问题的输出只与其输入有关，理所应当会想到，我们将所有的输入和输出通过字典储存，在每次运算时，都去字典查找是否计算过相同输入的输出，如果是则直接取输出，否则才计算。这种方法叫做==<a href="https://zh.wikipedia.org/wiki/%E8%AE%B0%E5%BF%86%E5%8C%96">Memoization（记忆化）</a>==。记忆化是一种提高程序运行速度的优化技术。通过储存大计算量函数的返回值，当这个结果再次被需要时将其从缓存提取，而不用再次计算来节省计算时间。 记忆化是一种典型的时间存储平衡方案。</p>
<p>某个方法很多次，在这很多次的调用中，部分计算是完全可重用的，则可以设计一个缓存机制，将中间的一些重要中间结果缓存下来，如果后续的运算命中了之前的缓存，则可以减少重复计算，提升程序效率。</p>
<p>python的LRU(Least Recently Used)为我们提供了这样一种缓存机制，只需要在函数前面加上<code>@functools.lru_cache()</code>就可以实现。我们使用上面递归超时的例子：</p>
<pre><code class="language-python">import functools
class Solution(object):
    def numDecodings(self, s):
    # 尝试加入LRU cache来让原来超时的解法通过
        self.ans = 0
        return self.split_one(s)
    @functools.lru_cache()
    def split_one(self,cur_str):
        length = len(cur_str)
        ans = 0
        if length == 0:
            # 分解完毕
            return 1
        if not cur_str[0] == '0':
            ans+=self.split_one(cur_str[1:])
            if length &gt;= 2 and int(cur_str[:2]) &lt;= 26:
                # 两位也可以拿出来解释
                ans+=self.split_one(cur_str[2:])
        return ans

</code></pre>
<p>结果：</p>
<img src="https://s1.ax1x.com/2020/03/15/83oghQ.png" alt="LRU结果" style="zoom:50%;" />]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Leetcode标签含义汇总]]></title>
        <id>https://zxpzhong.github.io/post/leetcode算法题标签含义汇总</id>
        <link href="https://zxpzhong.github.io/post/leetcode算法题标签含义汇总">
        </link>
        <updated>2020-03-15T06:54:41.000Z</updated>
        <summary type="html"><![CDATA[<p>Leetcode标签含义汇总</p>
]]></summary>
        <content type="html"><![CDATA[<p>Leetcode标签含义汇总</p>
<!-- more -->
<h1 id="leetcode算法题标签含义汇总">leetcode算法题标签含义汇总</h1>
<h2 id="array">Array</h2>
<p>这个分类意义为数组，属于按输入类型的粗分类，只要和数组相关就会被分到该类下，所以对具体方法参考意义不大。</p>
<h2 id="backtracking">Backtracking</h2>
<p>回溯法。主要是针对暴力解法或者暴力递归过程中，如何减少可能出现大量的重复运算。比如运算到第K步，如果是暴力递归，那么每一次运算到第K步都需要计算前K步，但是对于回溯，可能避免重复计算前K步，是使用回溯还是递归，主要取决于运算过程中是否包含大量的重复计算。</p>
<h2 id="binary-indexed-tree">Binary Indexed Tree</h2>
<p>树状数组。<a href="https://blog.csdn.net/Jasmineaha/article/details/81462020">Binary Indexed Tree解释</a>，详见[分割树](##Segment Tree)。</p>
<h2 id="binary-search">Binary Search</h2>
<p>二分搜索。思想来源于排序数组的二分搜索，这个思想也可以用在很多排序问题搜索的问题上。</p>
<h2 id="bit-manipulation">Bit Manipulation</h2>
<ol>
<li>位操作，包含（示例代码使用python，变量<code>a = 3(0011) b = 4(0101)</code>）：</li>
</ol>
<ul>
<li>
<p>与：<code>a&amp;b = 1(0001)</code></p>
</li>
<li>
<p>或：<code>a|b = 7(0111)</code></p>
</li>
<li>
<p>非：<code>~a = -4</code>(3取反后首位为1，是负数，负数以补码形式储存得-4)</p>
</li>
<li>
<p>左移：<code>a&lt;&lt;1 = 6</code></p>
</li>
<li>
<p>右移：<code>a&gt;&gt;1 = 1</code></p>
</li>
<li>
<p>置位：<code>a = a|(2**2)</code>(对第二位置位，python没有置位操作，可以用或完成)</p>
</li>
<li>
<p>复位：<code>a = a&amp;(255-2**2)</code>(第二位复位，python没有置位操作，可以用或完成)</p>
</li>
<li>
<p>异或：<code>a^b = 0110</code>(相同为0，不同为1)</p>
</li>
</ul>
<ol start="2">
<li>位操作中比较经典的就是格雷码（Gray Code），格雷码是相邻两个编码有且只有一位差别，基础且经典的问题是格雷码的生成问题，有以下两个方法：</li>
</ol>
<ul>
<li>
<p>按位数生成序列：已知两位的格雷码为：<code>00 01 11 10</code>,从三位的格雷码开始，先在二位的格雷码<strong>前</strong>添加0得到：<code>000 001 011 010</code>，再添加<code>1</code>并且调换两个的顺序得到：<code>110 111 101 100</code>，拼接后得到三位格雷码为：<code>000 001 011 010 110 111 101 100</code>，以此类推可以得到四位，五位。。。</p>
</li>
<li>
<p>（推荐）直接生成第n位格雷码：<code>Gray(n) = n XOR n/2</code></p>
</li>
</ul>
<h2 id="brain-teaser">Brain teaser</h2>
<p>智力题。这个分类其实不是很准确，只是算法题套上了智力题的外套，核心的算法部分各有不同，由于是动态的游戏过程，动态规划的方法可能比较适用。</p>
<h2 id="breadth-first-search">Breadth First Search</h2>
<p>广度优先搜索（BFS）。这个是最最基础的树遍历算法了，也叫做<strong>按层扫描输出</strong>。当然不仅仅在树搜索中很有用，更重要的是这个思想，可以用在很多需要提前停止的迭代过程中（BFS本身也是一种递归），最重要的是设计明确何时停止，递归调用如何一级一级返回，如果传回有用参数。这类题目的特点是：某问题<strong>有无</strong>符合条件的解/给出一个符合条件的解。</p>
<h2 id="depth-first-search">Depth First Search</h2>
<p>深度优先搜索（DFS）。这个也是最基础的数遍历算法了，在二叉树中根据取到左子叶、中节点和右子叶的顺序可以分为前序遍历、中序遍历和后续遍历。如同BFS一样，这种思想也很重要，这类问题的核心目标在于如何在深度优先搜索过程中进行剪枝，如果不进行剪枝，那么和暴力递归的复杂度一样了，基本上都会超时的。这列题目的特点是：给出某问题<strong>所有</strong>符合条件的解。</p>
<h2 id="design">Design</h2>
<p>设计。一般是要求你设计能实现某种功能的数据结构（堆栈、队列、链表、树、图、字典），当然肯定是和普通的不完全一样，但是也是基于基本的数据结构上进行修改的！</p>
<h2 id="divide-and-conquer">Divide And Conquer</h2>
<p>分治法。分治法也是把问题分块，只不过和递归的那种问题分块方法不同，分治法的分割方法是分割成完全独立的小问题，最终再将各个子问题的结果合并，可以看做各个问题是<strong>并行</strong>解决的。而递归的子问题，是每次解决问题时的一小部分然后用这一步的结果作为下一步的初始状态，是<strong>串行</strong>解决的。</p>
<h2 id="dynamic-programming">Dynamic Programming</h2>
<p>动态规划。解题神器！！动态规划的核心是建立状态和动态转移方程的概念（可以用状态机标识），每一步的决策都与只与特定的状态相关联，一般用递归或者DFS超时的，都可以考虑DP，再广泛一点说，只要是做动态决策的，基本上都可以用DP方法解决，而且复杂度一般来讲都是最低的（一般是O(nm),m为单次决策的复杂度）！！</p>
<p>动态规划的思考流程：</p>
<ol>
<li>动态决策过程中，当前的最优选项是否只取决于当前或过去的状态（能否用动态规划解决）</li>
<li>当前的最优选项是否能够用历史状态表达（<mark>转移方程</mark>，等价于可以用状态机表示）</li>
<li>最终问题的解与状态的关系（输出）</li>
</ol>
<h2 id="geometry">Geometry</h2>
<p>几何。这个标签含义不明，该标签下一共三题，一题二维平面，一题图的传播，第三题与几何无关</p>
<h2 id="graph">Graph</h2>
<p>图。</p>
<h2 id="greedy">Greedy</h2>
<p>贪心算法。解决一个问题需要很多步，但是每一步都选择当前状态下最优的选择，并且最终的最优结果也是每一步的最优结果的堆叠（当然很多问题是不符合这个的，所以要取决于最终问题，如果某步不是最优，可能再用回溯的方法回到当前步再取次优）！贪心算法的步骤大约可以分为三步：</p>
<ol>
<li>
<p>确定初始条件</p>
</li>
<li>
<p>采用迭代的过程，当可以向目标前进一步时，就根据局部最优策略，得到一部分解，缩小问题规模</p>
</li>
<li>
<p>将所有解综合起来</p>
</li>
</ol>
<h2 id="hash-table">Hash Table</h2>
<p>哈希表（散列表）。是储存键值对数据的一种数据储存方式，如果采用列表储存键值对数据，则需要的空间复杂度为O(2n)，单次查找的时间复杂度为O(n)，可以将所以找到索引值的时间复杂度降为O(1)。其核心在于哈希函数的设计，即如何设计键（key）和地址的计算关系。常用的哈希函数构造方法有：</p>
<ol>
<li>直接定址法：取关键字或者关键字的某个线性函数为Hash地址，即address(key)=a*key+b;如知道学生的学号从2000开始，最大为4000，则可以将address(key)=key-2000作为Hash地址。</li>
<li>平方取中法：对关键字进行平方运算，然后取结果的中间几位作为Hash地址。假如有以下关键字序列{421，423，436}，平方之后的结果为{177241，178929，190096}，那么可以取中间的两位数{72，89，00}作为Hash地址。</li>
<li>折叠法：将关键字拆分成几部分，然后将这几部分组合在一起，以特定的方式进行转化形成Hash地址。假如知道图书的ISBN号为8903-241-23，可以将address(key)=89+03+24+12+3作为Hash地址。</li>
<li>除留取余法：如果知道Hash表的最大长度为m，可以取不大于m的最大质数p，然后对关键字进行取余运算，address(key)=key%p。</li>
</ol>
<p>看完上面哈希函数的设计，理所当然得会想到，上面任意一中哈希函数方法在进行计算地址时，地址都会出现不连续的情况，所以在分配哈希表时，必须提前预分配一个更大的空间，造成空间的浪费；或者因为分配的空间太小，造成哈希冲突，所以哈希表大小的确定也十分重要（这里我也不懂了）。上面提到的哈希冲突，即两个不同的键值对通过哈希函数的映射后储存于同一地址的情况，这样会造成数据的丢失。哈希冲突一般有<a href="https://www.jianshu.com/p/de33dc676a3f">两种解决办法</a>：</p>
<ol>
<li>开放定址法：即当一个关键字和另一个关键字发生冲突时，使用某种探测技术在Hash表中形成一个探测序列，然后沿着这个探测序列依次查找下去，当碰到一个空的单元时，则插入其中。比较常用的探测方法有线性探测法，比如有一组关键字{12，13，25，23，38，34，6，84，91}，Hash表长为14，Hash函数为address(key)=key%11，当插入12，13，25时可以直接插入，而当插入23时，地址1被占用了，因此沿着地址1依次往下探测(探测步长可以根据情况而定)，直到探测到地址4，发现为空，则将23插入其中。</li>
<li>采用数组和链表相结合的办法，将Hash地址相同的记录存储在一张线性表中，而每张表的表头的序号即为计算得到的Hash地址。</li>
</ol>
<p>在实际使用中，python的dict就是哈希表，哈希的思想也可以用在很多需要重复索引某一值的情况，可以一次遍历构造哈希表O(n)，之后的索引就可以在O(1)下完成了！</p>
<h2 id="heap">Heap</h2>
<p>堆。讲到堆，肯定有人会想到栈，还有堆栈，列表和队列。那么这些名称分别有什么相同和不同呢。首先来区分堆/栈/堆栈、列表和队列：</p>
<ul>
<li>列表：大家最常用了，它是顺序储存的，即相邻元素储存于连续地址中，所以他的索引速度是最快的，只需要O(1)，但是插入元素的时则需要频繁得移动元素到后面去，最大的插入操作复杂度为O(n)。（<strong>c++11是这样，python待验证</strong>，如果脱离具体语言实现去思考的话，确实是这样的）</li>
<li>队列：现进先出</li>
<li>堆/栈/堆栈
<ul>
<li>栈（堆栈）：先进后出，一种数据结构</li>
<li>堆：程序运行时动态申请的内存，比如调用函数时的局部变量，运算过程中申请开辟的内存都属于堆，栈是堆的一种使用方法（先进后出，最经典的就是函数调用时，保护现场和还原现场时的入栈和出栈操作）。所以说堆不能完全算作一种数据结构，只不过在不同的语言或者领域中，有时候叫栈有时候叫堆栈，所以很多人把堆的概念也混进来了！</li>
</ul>
</li>
</ul>
<h2 id="line-sweep">Line Sweep</h2>
<p><a href="https://www.jianshu.com/p/d9be99077c2b">扫面线算法</a>。大概的内容是：二维平面上的多边形在图像中可以以坐标列表（比如[[2,2],[5,1],[11,3]]）的形式表示，如果需要转化为二维平面上的图形显示出来，需要对多边形内部进行填充。线扫描算法的思想就是利用一条条水平线对图像进行扫描，并且对处于多边形内部的区域进行填充，大致的原理是这样，但是具体的实现上还是需要注意很多细节。</p>
<img src="https://s1.ax1x.com/2020/03/14/8Q8q4P.png" style="zoom:60%;" />
<p>这个Tag下只有三道题目,其中[880]可以用逐层分解字符串的方法解出，[218] [391]可以使用扫描线算法的思想解出。</p>
<h2 id="linked-list">Linked List</h2>
<p>链表。链表是逻辑上具有一定顺序，空间上可以任意排布的一种数据结构（链表的索引复杂度为O(n)，插入操作在定位到元素后只需要修改指针值即可完成插入，而不需要像连续储存的数据结构，每次增删需要移动后续所有的元素），也是一种递归的数据结构。根据链表的连接方式可以分为：</p>
<ul>
<li>单向链表：每个节点（Node）只包含指向下一个元素的指针，无法从链表中间的任一元素追溯到上一元素。</li>
<li>双向链表：每个节点包含一个向下一个向上的指针，可以由任一节点追溯到整个链表。C++11中的<code>list</code>容器采用双向链表实现，具有极快的随机增删速度。</li>
<li>循环链表：首尾相接的链表，拓扑结构上呈现一个环状。</li>
</ul>
<p><strong>Tips</strong>: python的list可以使用下表直接索引，是因为list采用数组的形式储存。那为什么list可以放入不同类型的元素呢？因为python的list中存入的其实是元素的地址，python中对变量的值修改并不会直接修改该内存区域的值，而是变量指向另一片储存区域。</p>
<p><strong>链表必备方法</strong>：</p>
<ol>
<li>链表的正序逆序索引：正序索引O(n)，逆序索引O(2n)</li>
<li><mark>链表翻转</mark>：O(n)</li>
<li>判断是否有环：双指针</li>
<li>删除重复元素</li>
<li>还有很多变种，还没来得及整理！</li>
</ol>
<h2 id="math">Math</h2>
<p>数学。这个分类比较杂，只要涉及数学运算的好像都会被放到这个分类下来，比如四则运算、质数、丑数、指数运算、幂运算、排列组合等等，所采用的的方法和具体题型有关。</p>
<h2 id="memoization">Memoization</h2>
<p><a href="https://zh.wikipedia.org/wiki/%E8%AE%B0%E5%BF%86%E5%8C%96">记忆化</a>。在计算机科学中，记忆化是一种提高程序运行速度的优化技术。通过储存大计算量函数的返回值，当这个结果再次被需要时将其从缓存提取，而不用再次计算来节省计算时间。 记忆化是一种典型的时间存储平衡方案。</p>
<p>比如需要调用某个类的某个方法很多次，在这很多次的调用中，部分计算是完全可重用的，则可以设计一个缓存机制，将中间的一些重要中间结果缓存下来，如果后续的运算命中了之前的缓存，则可以减少重复计算，提升程序效率。</p>
<p>暴力递归变为回溯法可以看做一种记忆化方法。</p>
<p>缓存的用处：</p>
<ul>
<li>浏览器缓存</li>
<li>DNS缓存</li>
<li><a href="https://blog.csdn.net/lynn_Kun/article/details/77463779">数据库的读取</a></li>
<li>CPU的多级缓存</li>
<li>硬盘数据读取缓存</li>
</ul>
<p>leetcode该分类下只有一题[329]，其实还有其他题目，但是我懒得找了，不在这列举了！</p>
<h2 id="minimax">Minimax</h2>
<p><a href="https://www.zhihu.com/question/27221568">极大值极小值算法</a>。极大值极小值算法是一种DFS算法， 如果游戏较为简单（比如井字棋），可以通过DFS遍历出所有的可能步骤和对应的结果，然后通过极大值极小值算法反推出在任何一步，你应该如何执行操作。（井字棋机器人我本科的时候还拿Uarm机械臂和摄像头做过  - - ！）</p>
<p>当然井字棋可以穷举，但是对于绝大部分的游戏，都无法进行穷举，只可能考虑接下来的几步，因此需要对当前和接下来的某几步所产生的局面进行评分，这个评分的函数称作估值函数。极大极小方法往往指的是基于静态估值函数的有限深度的极大极小搜索，即可以对每个局面进行静态打分，而与之前的局面无关，再对有限深度（比如3步）进行极大极小搜索，从而得出当前应该执行什么操作。</p>
<h2 id="ordered-map">Ordered Map</h2>
<p>排序字典。前面提到了Hash Table，python中的字典就是Hash Table，但是字典中的键值对没有顺序，对字典进行遍历输出时，键值对的输出顺序没有含义(与加入字典的顺序无关)。但是对于pyhton的排序字典（OrderedDict）而言，键值对在加入字典时，会像列表一样，添加在尾部，从而在遍历排序字典时，可以获得和输入顺序同样的遍历顺序。</p>
<p><strong>经过验证，python2、3的dict都会按添加顺序输出！但是如果确实需要保证输出顺序时，还是建议使用OrderedDict</strong></p>
<pre><code class="language-python">import collections
print('Regular dictionary:')
d={}
d['a']='A'
d['c']='C'
d['z']='Z'
d['b']='B'
for k,v in d.items():
    print(k,v)
print('OrderedDict:')
d=collections.OrderedDict()
d['a']='A'
d['c']='C'
d['z']='Z'
d['b']='B'
for k,v in d.items():
    print(k,v)
</code></pre>
<p>输出为：</p>
<pre><code class="language-python">Regular dictionary:
a A
c C
z Z
b B
OrderedDict:
a A
c C
z Z
b B
</code></pre>
<h2 id="queue">Queue</h2>
<p><a href="https://zhuanlan.zhihu.com/p/81018602">队列</a>。先入先出（First In First Out, FIFO）的数据结构。</p>
<pre><code class="language-python">import queue
q = queue.Queue()
for i in range(4):
    q.put(i)
while not q.empty():
    print(q.get())
</code></pre>
<p>输出为：</p>
<pre><code>0
1
2
3
</code></pre>
<p>由于队列的性质比较简单，该Tag下的题目较少，而且也都比较简单。除了使用python3内置的<code>queue</code>当然更多时候我们可以选择使用<code>list</code>手动实现一个队列。因为list用的多顺手嘛。</p>
<h2 id="random">Random</h2>
<p>这个分类也不知道啥含义，Tag含义为随机，对应到分类下的题目，是想说这些题中都存在一定的随机过程，但是很多题都有随机过程啊，而且大多数题目最终在限制条件下的最优解一般只有一个。</p>
<h2 id="recursion">Recursion</h2>
<p>递归。递归由于其太过暴力，往往会因为超过复杂度限制而被抛弃，但是在很多改进的剪枝方法中，原始的递归的思想都非常重要！！但是这个分类下却只有10道题，还是分类没有分好。。。</p>
<p>递归的构建流程相对会简单很多，但是往往会造成大量重复运算（复杂度一般等价于暴力grid search），作为第一眼看到想出的方法或者想不出其他方法时可以尝试一下，万一AC了呢？</p>
<ol>
<li>分析整个问题能否分解为多个完全一样的的<mark>串行解决</mark>的子问题（能否递归）</li>
<li>每个串行解决的子问题如何递归得到下一个串行解决的子问题（子问题分解）</li>
<li>初始条件和终止条件，结果的汇总一般使用全局变量接收（初始条件和终止条件）</li>
</ol>
<h2 id="rejection-sampling">Rejection Sampling</h2>
<p>拒绝采样，也叫做接受/拒绝采样（Accept-Reject Sampling）。比如要在一个矩形中实现均匀采样，可以对横纵坐标都从均匀分布中采样，但是如果要对圆均匀采样呢，甚至是对不规则图形进行均匀采样，就比较困难了，因为要构建在非矩形图形中构建均匀采样的概率分布大多数情况下是比较麻烦的。</p>
<p>对于分布<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">p(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>，选取一个容易采样的参考分布<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>q</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">q(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>，使得对于任意的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>都有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>⩽</mo><mi>M</mi><mo>⋅</mo><mi>q</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">p(x) \leqslant M \cdot q(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">⩽</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>,则可以按照如下过程进行采样：</p>
<ol>
<li>从参考分布<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>q</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">q(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>中随机抽取一个样本<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">x_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li>
<li>从均匀分布<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>U</mi><mo>(</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">U(0,1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>产生一个随机数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>u</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">u_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li>
<li>如果<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>u</mi><mi>i</mi></msub><mo>&lt;</mo><mfrac><mrow><mi>p</mi><mo>(</mo><msub><mi>x</mi><mi>i</mi></msub><mo>)</mo><mo>)</mo></mrow><mrow><mi>M</mi><mi>q</mi><mo>(</mo><msub><mi>x</mi><mi>i</mi></msub><mo>)</mo><mo>)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">u_{i}&lt;\frac{p(x_i))}{Mq(x_i))}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6891em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.53em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">M</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">q</span><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mclose mtight">)</span><span class="mclose mtight">)</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">p</span><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mclose mtight">)</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>,则接受样本<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">x_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，否则拒绝，重复直到接受</li>
</ol>
<h2 id="reservoir-sampling">Reservoir Sampling</h2>
<p><a href="https://www.jianshu.com/p/63f6cf19923d">蓄水池采样</a>。在一个给定长度的数组中随机等概率抽取一个数据很容易，但如果面对的是<mark>长度未知</mark>的海量数据流呢？蓄水池采样算法就是来解决这个问题的, 它在分析一些大数据集的时候非常有用。</p>
<ol>
<li>先选取数据流中的前<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>个元素，保存在集合<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span>中</li>
<li>从第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi><mo>(</mo><mi>k</mi><mo>+</mo><mn>1</mn><mo>&lt;</mo><mo>=</mo><mi>j</mi><mo>&lt;</mo><mo>=</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">j(k+1&lt;=j&lt;=n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>个元素开始，每次先以概率<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mo>=</mo><mi>k</mi><mi mathvariant="normal">/</mi><mi>j</mi></mrow><annotation encoding="application/x-tex">p=k/j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>选择是否让第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>个元素留下。若<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>被选中，则从A中随机选择一个元素并用该元素<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>替换它；否则直接淘汰该元素</li>
<li>重复步骤2直到结束，最后集合<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span>中剩下的就是保证随机抽取的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>个元素</li>
</ol>
<h2 id="segment-tree">Segment Tree</h2>
<p><a href="https://www.jianshu.com/p/6fd130084a43">线段树</a>。对于普通的线性储存数组<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span>，对于更新操作<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">a[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>的复杂度为O(1)，对于区间操作（比如区间求和，区间最小值、最大值）的复杂度为O(n)；而树状数组、线段树可以让更新和区间操作的复杂度都变为O(logn)。树状数组和线段树最大的区别在于，树状数组的每一个节点只保留了<strong>左子树</strong>，而线段树一般为<strong>完全二叉树</strong>（即满树），且树状数组要求不同层级的树之间可以满足加法运算。</p>
<h3 id="树状数组">树状数组</h3>
<p>要了解线段树，我们先来看<a href="https://blog.csdn.net/Jasmineaha/article/details/81462020">树状数组</a>。</p>
<img src="https://s1.ax1x.com/2020/03/15/81hn6f.png" alt="树状数组" style="zoom:50%;" />
<ol>
<li>
<p>上图是树状数组构造的一个过程，其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mn>1</mn><mo>−</mo><mi>A</mi><mn>8</mn></mrow><annotation encoding="application/x-tex">A1-A8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">A</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mord">8</span></span></span></span>是原始的线性储存数组(<strong>下标从1开始</strong>)，先要求对该数组进行更新和区间求和操作，更新操作复杂度为O(1)：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>=</mo><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">A[i]=target</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">A</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span></span></span></span>，区间<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>k</mi><mo separator="true">,</mo><mi>t</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[k,t]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">t</span><span class="mclose">]</span></span></span></span>求和操作复杂度为O(n)：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mi>k</mi></mrow><mi>t</mi></msubsup><mi>A</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">\sum_{i=k}^{t}A[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.233166em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.933456em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">A</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>。我们按照如下公式构建树状数组：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>C</mi><mi>i</mi></msub><mo>=</mo><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mi>i</mi><mo>−</mo><msup><mn>2</mn><mi>k</mi></msup><mo>+</mo><mn>1</mn></mrow><mi>i</mi></munderover><mi>A</mi><mo>[</mo><mi>j</mi><mo>]</mo><mo separator="true">,</mo><mi>k</mi><mo>=</mo><mi>l</mi><mi>o</mi><mi>w</mi><mi>b</mi><mi>i</mi><mi>t</mi><mo>(</mo><mi>j</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">C_i=\sum_{j=i-2^k+1}^{i}A[j],k=lowbit(j)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.3112020000000006em;vertical-align:-1.4995329999999998em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8116690000000006em;"><span style="top:-1.786575em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">=</span><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7820285714285713em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.4995329999999998em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">A</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">b</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span></span></p>
<p>其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><mi>w</mi><mi>b</mi><mi>i</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">lowbit</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">b</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span></span></span></span>运算为获取输入参数转为二进制后,最后一个1的位置所代表的数值：</p>
<pre><code class="language-python">def lowbit(x):
	reutrn x&amp;(-x)
</code></pre>
</li>
<li>
<p>根据上面的公式，我们可以得到</p>
<pre><code class="language-python">C1 = A1
C2 = A1 + A2
C3 = A3
C4 = C2 + C3 + A4 = A1 + A2 + A3 + A4
C5 = A5
C6 = C5 + A6 = A5 + A6
C7 = A7
C8 = C4 + C6 + C7 + A8 = A1 + A2 + A3 + A4 + A5 + A6 + A7 + A8
</code></pre>
<p>上面的公式和图中的完全对应上。那么接下来我们看看新构建的树状数组<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span>更新和区间求和的复杂度。</p>
</li>
<li>
<p><mark>更新操作</mark>：我们现在有已经构建好的树状数组<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span>，要对原数组中的某一个数实现更新，即对某一个数加上某一个数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi><mo separator="true">,</mo><mi>v</mi><mo>=</mo><mi mathvariant="normal">Δ</mi><mi>x</mi><mo>=</mo><msup><mi>x</mi><mo mathvariant="normal">′</mo></msup><mo>−</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">v,v=\Delta x=x&#x27;-x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Δ</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.835222em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>，那么对于树状数组，就是对包含有该位置的元素的所有节点加上<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span>。由于树状数组的深度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">logn</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span></span></span></span>，因此更新操作复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>：</p>
<pre><code class="language-python">def add(p,v):
  while p &lt;= n:
		nums[p] += v;
		p += lowbit(p)
    
</code></pre>
</li>
<li>
<p>区间求和操作：区间<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">(l,r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span>(<mark>左开右闭区间</mark>)的和为：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>u</mi><msub><mi>m</mi><mo>(</mo></msub><mi>r</mi><mo>)</mo><mo>−</mo><mi>s</mi><mi>u</mi><mi>m</mi><mo>(</mo><mi>r</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">sum_(r)-sum(r)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1052em;vertical-align:-0.3551999999999999em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mopen mtight">(</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">)</span></span></span></span>，区间求和复杂度也就<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>。</p>
<pre><code class="language-python">def sum_(p):
  ans =0
	while p&gt;0:
    ans += nums[p]
    p -= lowbit(p)
	return ans;    
</code></pre>
</li>
</ol>
<h3 id="线段树">线段树</h3>
<ol>
<li>
<p>从上面树状数组的定义可以看出，能实现快速区间操作的<mark>关键</mark>在于，可以通过左节点的值和当前子树的值，通过加减运算直接得出右子树的值，也就是满足加法运算法则，当然不只是加法，只要满足<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>+</mo><mi>b</mi><mo>=</mo><mi>c</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">则</mi><mi>c</mi><mo>−</mo><mi>a</mi><mo>=</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a+b=c，则c-a=b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">c</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">则</span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span>的运算都可以用树状数组实现。但是很多操作也不满足加法运算，比如经典的取最大取最小操作，这个时候就可以借助线段树实现更新和区间查询复杂度都为O(logn)。</p>
<img src="https://s1.ax1x.com/2020/03/15/81TvfH.png" alt="线段树" style="zoom:50%;" />
</li>
<li>
<p>比如上述的橘色数组，我们要其进行更新和区间最小值运算，更新复杂度和区间运算复杂度分别为O(1)和O(n)，线段树相对来说更好理解的一点是：它其实是利用了分治的思想来构建线段树。上图橘色数组对应的线段树为：</p>
<img src="https://s1.ax1x.com/2020/03/15/81HTZ6.png" alt="线段树" style="zoom:50%;" />
<p>线段树每一个位置代表原数组的区间为：</p>
<pre><code class="language-python">segmentTree[1] = arr[0:8] # python的[a:b]为左闭右开区间[a,b)
segmentTree[2] = arr[0:4]
segmentTree[3] = arr[4:8]
segmentTree[4] = arr[0:2]
segmentTree[5] = arr[2:4]
segmentTree[6] = arr[4:6]
segmentTree[7] = arr[6:8]
segmentTree[8] = arr[0]
segmentTree[9] = arr[1]
segmentTree[10] = arr[2]
segmentTree[11] = arr[3]
segmentTree[12] = arr[4]
segmentTree[13] = arr[5]
segmentTree[14] = arr[6]
segmentTree[15] = arr[7]
</code></pre>
</li>
<li>
<p>更新操作：</p>
<pre><code class="language-python">def update(i, value):
  i = i + n
  segmentTree[i] = value
  while i &gt; 1:
    i = i / 2
    segmentTree[i] = merge(segmentTree[2*i], segmentTree[2*i+1])
</code></pre>
</li>
<li>
<p>区间查询：</p>
<pre><code class="language-python">import sys
def minimum(left, right):
  left = left + n
  right = right + n
  minimum = sys.maxsize
  while left &lt; right:
    if left%2 == 0:
      # left is out of range of parent interval, check value of left node first, then shift it right in the same level
      minimum = min(minimum, segmentTree[left])
      left = left + 1
    if right%2 == 0:
      # right is out of range of current interval, shift it left in the same level and then check the value
      right = right - 1
      minimum = min(minimum, segmentTree[right])
    # move left and right one level up
    left = left / 2
    right = right / 2
</code></pre>
</li>
</ol>
<h2 id="sliding-window">Sliding Window</h2>
<p><a href="https://www.zhihu.com/question/314669016">滑动窗口算法</a>。这个方法对于我们做CV的人来说真的太熟悉了，不过多介绍了😊。</p>
<p>它可以用以解决数组/字符串的子元素问题，它可以将嵌套的循环问题，转换为单循环问题，降低时间复杂度。滑动窗口算法的<strong>核心</strong>在于，每次滑动窗口后，只需要在原来窗口的的基础上额外考虑移出窗口的元素和新移入窗口的元素，而不需要考虑窗口的长度。从而让整个过程的复杂度从O(mn)降为O(n)，其中m为窗口长度。</p>
<h2 id="sort">Sort</h2>
<p><a href="https://www.cnblogs.com/Mufasa/p/10527387.html">十大经典排序算法</a>。</p>
<h3 id="分类">分类</h3>
<ol>
<li>
<p>比较类排序</p>
<ul>
<li>
<p>交换排序</p>
<ul>
<li><mark>冒泡排序</mark>：前后元素比较后，进行<mark>交换（冒泡）</mark>，每<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>轮都会将第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>大的数据放到数组尾部，需要重复<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>次，每次遍历的元素个数为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mi>i</mi></mrow><annotation encoding="application/x-tex">n-i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>，最终的复杂度为O(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mi>n</mi><mo>(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{n(n+1)}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.355em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>)​=O(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">n^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>)。原地修改，空间复杂度为O(1)。</li>
<li><a href="https://wiki.jikexueyuan.com/project/easy-learn-algorithm/fast-sort.html">快速排序</a>：选取一个基准值，从数组两端分别遍历，然后小数在左大数在右的原则进行交换。</li>
</ul>
</li>
<li>
<p>插入排序</p>
<ul>
<li><mark>简单插入排序</mark>：逐个插入到前面的有序数中。第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>轮迭代，将第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>个数插入到前<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>个数中并且仍然保证插入后前<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>个数仍为有序数列。时间复杂度为O(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mi>n</mi><mo>(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{n(n+1)}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.355em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>)=O(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">n^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>)。原地修改，空间复杂度为O(1)。</li>
<li><mark><a href="https://www.cnblogs.com/chengxiao/p/6104371.html">希尔排序</a></mark>：从大范围到小范围进行比较-交换，类似冒泡和插入的联合。</li>
</ul>
</li>
<li>
<p>选择排序</p>
<ul>
<li><mark>简单选择排序</mark>：第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>轮遍历选择第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>小的数放在前面，选择第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>小的数后直接与第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>个数进行交换。第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>轮的筛选范围从第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>个元素开始，因此最终的复杂度为O(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mi>n</mi><mo>(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{n(n+1)}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.355em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>)=O(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">n^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>)。原地修改，空间复杂度为O(1)。</li>
<li>堆排序：利用最大堆和最小堆的特性</li>
</ul>
</li>
<li>
<p>归并排序（分治法插入排序）</p>
<ul>
<li>二路归并排序，依次按前2个前4个前8个前16个。。。进行插入排序。</li>
<li>多路归并排序</li>
</ul>
</li>
</ul>
</li>
<li>
<p>非比较类排序</p>
<ul>
<li>计数排序：字典计数-还原，空间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>+</mo><mi>k</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n+k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span>，直接对数字进行字典计数然后按键的大小顺序还原值个键，典型的空间换时间方法！</li>
<li><a href="https://dailc.github.io/2016/12/03/baseKnowlenge_algorithm_sort_bucketSort.html">桶排序</a>：分为K个桶，将最大到最小值分为平分为K个区间（桶），每个桶在分数据的时候维护桶内一个排序堆，当所有的数据都分完，各个桶的数据再串联起来，就得到结果。是最快也是最耗空间的方法！</li>
<li><a href="https://www.cnblogs.com/sun/archive/2008/06/26/1230095.html">基数排序</a>：基数排序的主要思路是,将所有待比较数值(<strong>注意,必须是正整数</strong>)统一为同样的数位长度,数位较短的数前面补零. 然后, 从最低位开始, 依次进行一次<mark>稳定排序</mark>（即高位相同的情况下不会打乱低位的排序结果）, 因为<strong>每个位可能的取值范围是固定的从0到9</strong>)。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。</li>
</ul>
</li>
</ol>
<h3 id="复杂度">复杂度</h3>
<img src="https://s1.ax1x.com/2020/03/15/83keCd.png" alt="十种排序算法复杂度" style="zoom:30%;" />
<h2 id="stack">Stack</h2>
<p>栈。前面的<a href="##Heap">堆</a>处介绍过了，这里不重复介绍了。</p>
<h2 id="string">String</h2>
<p>字符串。该分类比较杂，与字符串相关的题目都会汇总到这里来。</p>
<h2 id="topological-sort">Topological Sort</h2>
<p><a href="https://www.jianshu.com/p/3347f54a3187">拓扑排序</a>。</p>
<h2 id="tree">Tree</h2>
<p>树。这里的分类比较杂， 所以的树都放到这里来了。</p>
<ul>
<li>树的分类</li>
<li>典型方法</li>
<li>经典题型</li>
</ul>
<h2 id="two-pointers">Two Pointers</h2>
<p>双指针。主要用于遍历数组，两个指针指向不同的元素，从而协同完成任务。双指针可以从不同的方向向中间逼近也可以朝着同一个方向遍历。经典题目如：两数和、原地删除重复字符、原地翻转字符、回文串、链表是否有环等等。</p>
<h2 id="union-find">Union Find</h2>
<p><a href="https://blog.csdn.net/Yaokai_AssultMaster/article/details/78888846">并查集</a>。<strong>并查集</strong>是一种树型的数据结构，用于处理一些<a href="https://zh.wikipedia.org/wiki/%E4%B8%8D%E4%BA%A4%E9%9B%86">不交集</a>（Disjoint Sets）的合并及查询问题。</p>
<h2 id="unknow">Unknow</h2>
<p>未知。该分类下有超过200道题目，题型相比其他也许并不那么常规，但是他们中的绝大部分所采用的解法仍然是前面所有Tag中提到的算法。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[pytorch多GPU并行运算]]></title>
        <id>https://zxpzhong.github.io/post/pytorch-duo-gpu-bing-xing-yun-suan</id>
        <link href="https://zxpzhong.github.io/post/pytorch-duo-gpu-bing-xing-yun-suan">
        </link>
        <updated>2019-06-19T15:09:07.000Z</updated>
        <summary type="html"><![CDATA[<p>pytorch使用多块GPU并行运算</p>
]]></summary>
        <content type="html"><![CDATA[<p>pytorch使用多块GPU并行运算</p>
<!-- more --> 
<h1 id="pytorch多gpu运行">Pytorch多GPU运行</h1>
<ol>
<li>设置可用GPU环境变量。例如，使用0号和1号GPU'<br>
<code>os.environ[&quot;CUDA_VISIBLE_DEVICES&quot;] = '0,1'</code></li>
<li>设置模型参数放置到多个GPU上。在pytorch1.0之后的版本中，多GPU运行变得十分方便，先将模型的参数设置并行</li>
</ol>
<pre><code>        if torch.cuda.device_count() &gt; 1:
            print(&quot;Let's use&quot;, torch.cuda.device_count(), &quot;GPUs!&quot;)
            model = nn.DataParallel(model)
</code></pre>
<ol start="3">
<li>将模型参数设置使用GPU运行</li>
</ol>
<pre><code>        if torch.cuda.is_available():
            model.cuda()
</code></pre>
<h1 id="踩坑记录">踩坑记录</h1>
<ol>
<li>在训练中，需要使用验证集/测试集对目前的准确率进行测试，验证集/测试集的加载也会占用部分显存，所以在训练开始时，不要将所有显存都几乎占满，稍微留一些显存给训练过程中的测试环节</li>
<li>pytorch并行后，假设batchsize设置为64，表示每张并行使用的GPU都使用batchsize=64来计算（单张卡使用时，使用batchsize=64比较合适时，多张卡并行时，batchsize仍为64比较合适，而不是64*并行卡数）。</li>
</ol>
<h1 id="参考">参考</h1>
<ol>
<li><a href="https://www.zhihu.com/question/67726969">https://www.zhihu.com/question/67726969</a></li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[天池Docker提交]]></title>
        <id>https://zxpzhong.github.io/post/tian-chi-docker-ti-jiao</id>
        <link href="https://zxpzhong.github.io/post/tian-chi-docker-ti-jiao">
        </link>
        <updated>2019-06-19T15:07:49.000Z</updated>
        <summary type="html"><![CDATA[<p>天池竞赛提交如何提交Docker镜像？相信很多小伙伴容易倒在第一步上~~</p>
]]></summary>
        <content type="html"><![CDATA[<p>天池竞赛提交如何提交Docker镜像？相信很多小伙伴容易倒在第一步上~~</p>
<!-- more -->
<h1 id="天池竞赛简介">天池竞赛简介</h1>
<ul>
<li>天池大数据竞赛是由阿里巴巴集团主办，面向全球科研工作者的高端算法竞赛。通过开放海量数据和分布式计算资源，大赛让所有参与者有机会运用其设计的算法解决各类社会问题或业务问题。特别优秀的解决方案将有机会直接上线阿里巴巴旗下各电商网站（含淘宝、天猫等）或第三方合作伙伴平台，服务中国乃至世界数以亿计的用户。</li>
<li>这个竞赛在国内的地位可以比肩Kaggle，在竞赛中拿到好的成绩可以直接写上简历，加分还是很足的，具体优点我就不列举了，现在体会还那么深刻，但是前人的经验告诉我们，参加这个百利而无一害！！！！</li>
<li>B乎问答“参加天池对校招的作用”：<br>
<a href="https://www.zhihu.com/question/41449961" title="参加天池大数据竞赛对校园招聘有帮助吗？">https://www.zhihu.com/question/41449961</a></li>
</ul>
<h1 id="docker简介">Docker简介</h1>
<p>参加天池竞赛不可避免得要碰到一个问题，那就是最基本得提交赛题，本次我遇到的是通过提交<strong>阿里容器镜像服务</strong>的地址，竞赛刚看完题目后，第一遍提交应该是使用赛题提供的Demo文件提交，这样可以熟悉一遍赛题，熟悉提交流程。所以一定要先对Docker进行一个科普性了解。</p>
<h2 id="docker是什么">Docker是什么？</h2>
<ul>
<li>Docker是一个虚拟环境容器，可以将你的开发环境、代码、配置文件等一并打包到这个容器中，并发布和应用到任意平台中。比如，你在本地用Python开发网站后台，开发测试完成后，就可以将Python3及其依赖包、Flask及其各种插件、Mysql、Nginx等打包到一个容器中，然后部署到任意你想部署到的环境。<img src="https://s2.ax1x.com/2019/07/30/eGRf8e.png" alt="mark" loading="lazy"></li>
<li>大家从github上拉下来的代码，能直接运行么？往往不能，因为：</li>
<li>代码运行系统环境不同</li>
<li>数据集的文件夹路径不同</li>
<li>python依赖不同，可能你的环境中没装，可能你的版本过高或者过低</li>
<li>版本差别比较大的深度学习框架，有些函数有差异，是修改当前python的框架版本？还是新建虚拟环境重新装一个？</li>
<li>所以从github上拉下来的代码，多多少少还是要经过修改后才能正常运行，修改少的十分钟可以运行起来，多的需要一个小时以上，但是赛题方不可能帮你把你提交的代码全部修改后，然你的代码能够在赛题方的环境中运行，所以这种要求<strong>程序跨环境运行</strong>的要求就需要靠Docker来解决！！</li>
</ul>
<h2 id="docker基本概念">Docker基本概念</h2>
<p>说白了，Docker就是一个能够把你的运行环境也打包的容器，这样才能够让你的提交给赛题方的容器，可以不经过任何修改而直接运行，得出你的成绩。真正使用前还需要了解一些基本概念：镜像、容器、仓库。</p>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">打包后大小</th>
<th style="text-align:center">运行底层</th>
<th style="text-align:center">响应时间（包含修改）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">代码打包</td>
<td style="text-align:center">MB级别</td>
<td style="text-align:center">python+本机操作系统</td>
<td style="text-align:center">小时级别</td>
</tr>
<tr>
<td style="text-align:center">虚拟机</td>
<td style="text-align:center">10G级别</td>
<td style="text-align:center">虚拟化硬件+虚拟机</td>
<td style="text-align:center">开机5分钟</td>
</tr>
<tr>
<td style="text-align:center">Docker</td>
<td style="text-align:center">5G级别</td>
<td style="text-align:center">操作系统的Docker引擎</td>
<td style="text-align:center">秒级</td>
</tr>
</tbody>
</table>
<figure data-type="image" tabindex="1"><img src="https://s2.ax1x.com/2019/07/30/eGRhgH.png" alt="mark" loading="lazy"></figure>
<ol>
<li>Docker的gitbook地址，有时间的话建议还是把这个全部看完。<a href="https://yeasy.gitbooks.io/docker_practice/">https://yeasy.gitbooks.io/docker_practice/</a></li>
<li><strong>镜像</strong>：镜像就像面向对象程序中的类，镜像是静态的定义，镜像可以被修改，增删内容，但是镜像的运行必须通过生成容器实体</li>
<li><strong>容器</strong>：容器就像面向对象程序中的示例，容器是镜像运行时的实体，容器可以被创建、启动、停止、删除、暂停</li>
<li><strong>仓库</strong>：这个仓库就类似git仓库，但是git仓库是储存代码，而docker仓库是储存docker镜像
<ul>
<li><code>Docker Registry</code>：Docker Registry就像是一个仓库基地，里面可以有很多独立的仓库（Repository）</li>
<li><code>Repository</code>：每个仓库中只能存放一个镜像，同一镜像的不同版本（tag）都放在同一仓库中</li>
<li><code>tag</code>：仓库中镜像的标签（tag）就对应于镜像的版本，取名一般为0.0/2.4等</li>
<li><code>jwilder/nginx-proxy:2.03</code>：表示Docker Registry为jwilder，Repository为nginx-proxy，版本为2.03</li>
</ul>
</li>
</ol>
<h1 id="如何在天池中提交docker成功拿到自己的分数精炼版">如何在天池中提交Docker成功拿到自己的分数（精炼版）</h1>
<h2 id="本地准备好代码">本地准备好代码</h2>
<p>按照赛题方要求，写好python代码的输入输出，做好输入参数检查，这里推荐使用<code>argparse</code>，使用demo</p>
<pre><code class="language-python">import argparse
# 获取参数
parser = argparse.ArgumentParser()
parser.add_argument('--arg1', dest='arg1', type=str, default=None, help='接受--arg1=的参数为变量arg1，类型为str,缺省值为None，参数对应的帮助文档为help的内容')
args = parser.parse_args()
# 执行python **.py --arg1=SSS 后args.arg1的值为'SSS'
</code></pre>
<h2 id="编写requirementstxt">编写requirements.txt</h2>
<p>检查你的代码中所有的import,然后使用pip list查看你本地使用的版本，在同级目录中添加requirements.txt</p>
<pre><code>Pillow==5.3.0
tqdm==4.19.2
torchnet==0.0.4
</code></pre>
<h2 id="编写docker文件">编写Docker文件</h2>
<p>这一步其实是<strong>最难也是最关键的</strong>，但是我们是为了使用Docker而使用，所以这一步简化再简化，这里直接提供一个可以使用的制作cuda8.0+pytorch1.0.1镜像的Docker文件，使用该文件可以直接生成cuda8.0+pytorch1.0.1镜像</p>
<pre><code># Modify from source: https://hub.docker.com/r/nvidia/cuda
# This Docker build is 3.1G
# -----------------------------------------------------------------------------
FROM ubuntu:16.04
LABEL maintainer &quot;NVIDIA CORPORATION &lt;cudatools@nvidia.com&gt;&quot;

RUN apt-get update &amp;&amp; apt-get install -y --no-install-recommends ca-certificates apt-transport-https bzip2 gnupg-curl wget &amp;&amp; \
    rm -rf /var/lib/apt/lists/* &amp;&amp; \
    NVIDIA_GPGKEY_SUM=d1be581509378368edeec8c1eb2958702feedf3bc3d17011adbf24efacce4ab5 &amp;&amp; \
    NVIDIA_GPGKEY_FPR=ae09fe4bbd223a84b2ccfce3f60f4b3d7fa2af80 &amp;&amp; \
    apt-key adv --fetch-keys https://developer.download.nvidia.com/compute/cuda/repos/ubuntu1604/x86_64/7fa2af80.pub &amp;&amp; \
    apt-key adv --export --no-emit-version -a $NVIDIA_GPGKEY_FPR | tail -n +5 &gt; cudasign.pub &amp;&amp; \
    echo &quot;$NVIDIA_GPGKEY_SUM  cudasign.pub&quot; | sha256sum -c --strict - &amp;&amp; rm cudasign.pub &amp;&amp; \
    echo &quot;deb https://developer.download.nvidia.com/compute/cuda/repos/ubuntu1604/x86_64 /&quot; &gt; /etc/apt/sources.list.d/cuda.list


ENV CUDA_VERSION 8.0.61

ENV CUDA_PKG_VERSION 8-0=$CUDA_VERSION-1
RUN apt-get update &amp;&amp; apt-get install -y --no-install-recommends \
        cuda-nvrtc-$CUDA_PKG_VERSION \
        cuda-nvgraph-$CUDA_PKG_VERSION \
        cuda-cusolver-$CUDA_PKG_VERSION \
        cuda-cublas-8-0=8.0.61.2-1 \
        cuda-cufft-$CUDA_PKG_VERSION \
        cuda-curand-$CUDA_PKG_VERSION \
        cuda-cusparse-$CUDA_PKG_VERSION \
        cuda-npp-$CUDA_PKG_VERSION \
        cuda-cudart-$CUDA_PKG_VERSION &amp;&amp; \
    ln -s cuda-8.0 /usr/local/cuda &amp;&amp; \
    rm -rf /var/lib/apt/lists/*

# nvidia-docker 1.0
LABEL com.nvidia.volumes.needed=&quot;nvidia_driver&quot;
LABEL com.nvidia.cuda.version=&quot;${CUDA_VERSION}&quot;

RUN echo &quot;/usr/local/nvidia/lib&quot; &gt;&gt; /etc/ld.so.conf.d/nvidia.conf &amp;&amp; \
    echo &quot;/usr/local/nvidia/lib64&quot; &gt;&gt; /etc/ld.so.conf.d/nvidia.conf

ENV PATH /usr/local/nvidia/bin:/usr/local/cuda/bin:${PATH}
ENV LD_LIBRARY_PATH /usr/local/nvidia/lib:/usr/local/nvidia/lib64

# nvidia-container-runtime
ENV NVIDIA_VISIBLE_DEVICES all
ENV NVIDIA_DRIVER_CAPABILITIES compute,utility
ENV NVIDIA_REQUIRE_CUDA &quot;cuda&gt;=8.0&quot;
#-----------------------------------------------------------------------------


#MiniConda Install
RUN wget &quot;https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh&quot; &amp;&amp; \
    bash ./Miniconda3-latest-Linux-x86_64.sh* -b -p &amp;&amp; \
    rm Miniconda3* 
ENV PATH=&quot;/root/miniconda3/bin:${PATH}&quot;

#Add Requirement Packages 
RUN conda install pytorch torchvision cudatoolkit=8.0 -c pytorch &amp;&amp; \
    conda clean -all --yes
</code></pre>
<p>执行完成后，将对应的Docker镜像push到阿里云Docker镜像服务，这样相当于有了一个自己的cuda8+pythch镜像，在这个镜像的基础上，再进行后续操作</p>
<pre><code>#Above image
FROM $你的阿里镜像地址
LABEL maintainer &quot;容器名称&quot;
#设置工作目录
WORKDIR /competition
#添加工作目录下的所有文件
ADD [^p^u]* /competition/
</code></pre>
<h2 id="编写runsh文件">编写run.sh文件</h2>
<p>run.sh文件是docker运行的入口，所以你的python执行文件命令必须在run.sh中写完整，<code>$1</code>在脚本中表示脚本接收到的第一个参数（也相当于docker运行的第一个参数），我们需要把这个参数传递给python执行</p>
<pre><code>#!/bin/bash
#
# run.sh is the entry point of the submission.
# nvidia-docker run -v ${INPUT_DIR}:/input_images -v ${OUTPUT_DIR}:/output_data
#       -w /competition ${DOCKER_IMAGE_NAME} sh ./run.sh /input_images /output_data/result.csv
# where:
#   INPUT_DIR - directory with input png images
#   OUTPUT_FILE - the classification result for each image
#

INPUT_DIR=$1
OUTPUT_FILE=$2

python main.py \
  --input_dir=&quot;${INPUT_DIR}&quot; \
  --output_file=&quot;${OUTPUT_FILE}&quot; \
</code></pre>
<h2 id="拉取官方私有docker基础镜像并且制作自己的镜像">拉取官方/私有Docker基础镜像，并且制作自己的镜像</h2>
<p>做好上述工作后，使用命令<code>sudo docker build -t $docker_name .</code>制作新的docker镜像，这时系统会拉取Docker文件中FROM地址对应的镜像，并且执行后续的修改，并且将其打包成新的镜像，镜像名称为<code>$docker_name</code>，</p>
<h2 id="自己的镜像添加改名版本号">自己的镜像添加改名版本号</h2>
<p>使用<code>sudo docker images</code>查看刚才自己制作的docker的$ID，并且使用如下命令对docker重命名，为后续的push设置仓库地址和版本号<br>
<code>sudo docker tag $ID registry.cn-shenzhen.aliyuncs.com/$你的阿里容器仓库地址:$版本号</code></p>
<h2 id="push自己的镜像">Push自己的镜像</h2>
<p>使用如下命令push自己的本地镜像到阿里云<br>
<code>sudo docker push registry.cn-shenzhen.aliyuncs.com/felix1/$你的阿里容器仓库地址:$版本号</code><br>
执行完毕后，可以在自己镜像仓库的镜像版本中看到自己推送的镜像，即完成了整个Docker的制作与推送</p>
<h1 id="感想">感想</h1>
<p>这也是我本人第一次用Docker，感觉Docker是在纯代码和虚拟机之间的一种折衷，既想方设法得保证所有环境都可以正常迁移到新的环境，又相比于虚拟机减少冗余部分，而只保留了程序运行所必须的部分，而且实测，新制作的Docker拉取到一台陌生的机器上时，可以完美直接运行，性能也基本没有下降，而且支持Docker直接使用本机显卡，这对深度学习使用Docker简直是福音。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ncnn c++模型测试]]></title>
        <id>https://zxpzhong.github.io/post/ncnn-cmo-xing-ce-shi</id>
        <link href="https://zxpzhong.github.io/post/ncnn-cmo-xing-ce-shi">
        </link>
        <updated>2019-06-19T15:06:41.000Z</updated>
        <summary type="html"><![CDATA[<p>ncnn模型c++代码测试</p>
]]></summary>
        <content type="html"><![CDATA[<p>ncnn模型c++代码测试</p>
<!-- more -->
<h1 id="ncnn-c测试">ncnn c++测试</h1>
<p>在模型转换完成后，紧接着就要真正在移动端上运行啦，不过在正式放到嵌入式设备上运行时（这一步也不属于我做），还是在PC上拿c++测试一下，确认没问题了才能说明模型的正确性</p>
<h1 id="ncnn安装">ncnn安装</h1>
<p>先使用git命令拉取ncnn源码</p>
<pre><code>git clone https://github.com/Tencent/ncnn
</code></pre>
<p>对ncnn进行编译、安装</p>
<pre><code>cd ncnn
mkdir build &amp;&amp; cd build
cmake ..
make -j
make install
</code></pre>
<p>执行完毕后，在$ncnn_dir/build/install/文件夹下会产生安装文件</p>
<ul>
<li>$ncnn_dir/build/install/lib/libncnn.a为链接库</li>
<li>$ncnn_dir/build/install/include/为头文件包含路径</li>
</ul>
<h1 id="cmake配置工程">Cmake配置工程</h1>
<p>在CMakeLists.txt中，加入如下代码，来添加ncnn的链接库和头文件路径</p>
<pre><code># 设置ncnn的链接库和头文件路径
include_directories($ncnn_dir/build/install/include/)
target_link_libraries($ncnn_dir/build/install/lib/libncnn.a)
</code></pre>
<p>由于本人模型输入为图片，因此还需要配置OpenCV,这里就不啰嗦了，直接参考如下链接安装：</p>
<p>Ubuntu16.04安装opencv for c++：<a href="https://blog.csdn.net/qq_33591712/article/details/83279982">https://blog.csdn.net/qq_33591712/article/details/83279982</a></p>
<p>其他Cmake基本配置，比如工程名、增加需要输出的可执行文件、链接OpenCV等等，在这里就不啰嗦了，参考如下链接<br>
<a href="https://www.cnblogs.com/lidabo/p/7359422.html">https://www.cnblogs.com/lidabo/p/7359422.html</a></p>
<h1 id="ncnn模型文件netparamsnetbin文件解析">ncnn模型文件net.params,net.bin文件解析</h1>
<ol>
<li>params包含了网络结构</li>
<li>bin包含了网络参数</li>
<li>对于使用该模型，最重要的是从这个网络结构中找到你要的输入输出节点名称，下面是一个网络结构的例子</li>
</ol>
<pre><code>7767517
60 63
Input            data             0 1 data 0=3 1=180 2=550
Convolution      ConvNd_1         1 1 data ConvNd_1 0=32 1=3 2=1 3=2 4=1 5=0 6=864
........................
....... 中间省略.........
........................
Dropout          Dropout_2        1 1 Addmm_1 Dropout_2
InnerProduct     Addmm_2          1 1 Dropout_2 Addmm_2 0=130 1=1 2=33280
Softmax          Softmax_1        1 1 Addmm_2 Softmax_1 0=0
</code></pre>
<ul>
<li>其中第一行的7767517是ncnn magic numger(幻数)，</li>
<li>第二行的60 63。60为layer number（网络层数），63为blob number（参数块数）</li>
<li>剩余的为Input            data             0 1 data 0=3 1=180 2=550，我们只关心中间的<code>data</code>,<code>Softmax_1</code>等，这是网络的节点名称，不论是输入还是输出节点，都必须在代码中指定输入输出节点名称</li>
</ul>
<h1 id="c代码">C++代码</h1>
<ol>
<li>包含ncnn头文件</li>
</ol>
<pre><code>#include &quot;net.h&quot;
</code></pre>
<ol start="2">
<li>读取输入图片</li>
</ol>
<pre><code>string img_path = &quot;$IMG_PATH&quot;;
cv::Mat img = cv::imread(img_path, CV_LOAD_IMAGE_COLOR);
cv::Mat img2;
//这里一定要检查你图片的大小和训练网络时的图片输入大小，要一样，否则到全连接层时会出现矩阵维数无法相乘
//input_width：网络输入图片宽度
//input_height：网络输入图片高度
cv::resize(img, img2, cv::Size(input_width, input_height));
</code></pre>
<ol start="3">
<li>加载ncnn模型和参数</li>
</ol>
<pre><code>// 加载模型和参数
ncnn::Net DeepNet;
DeepNet.load_param(&quot;$param_path&quot;);
DeepNet.load_model(&quot;$bin_path&quot;);
</code></pre>
<ol start="4">
<li>将读取的输入图片转化为ncnn::Mat input数据类型，通过ncnn自带的从图像像素转换函数</li>
</ol>
<pre><code>ncnn::Mat input = ncnn::Mat::from_pixels(img2.data, ncnn::Mat::PIXEL_BGR, img2.cols, img2.rows);
</code></pre>
<ol start="5">
<li>经输入Mat送入网络并定义输出节点获取结果</li>
</ol>
<pre><code>ncnn::Extractor extractor = DeepNet.create_extractor();
//    将'data'节点名称和ncnn::Mat input对应起来
extractor.input(&quot;data&quot;, input);
//    将'Addmm_1'节点名称和ncnn::Mat output对应起来
ncnn::Mat output;
extractor.extract(&quot;Addmm_1&quot;, output);
</code></pre>
<ol start="6">
<li>将ncnn::Mat类型的输出结果转化为std::vector<float></li>
</ol>
<pre><code>std::vector&lt;float&gt; &amp; cls_scores
//    网络输出为output,将output转化到cls_scores中输出
cls_scores.resize(output.cstep);
for(int j=0; j&lt;output.cstep; j++)
{
    const float* prob = (float*)output.data + output.c * j;
    cls_scores[j] = prob[0];
}
//Debug打印输出
for(int j = 0;j &lt; cls_scores.size();j++)
{
    cout &lt;&lt; cls_scores[j] ;
}
</code></pre>
<h1 id="调试trick">调试trick</h1>
<ol>
<li>对于输出节点，可以使用如下代码来打印节点的通道数和长宽，来判断该节点是否为你需要的那个输出节点（比如你要的输出为1<em>512</em>1,那么你可以根据你自己的网络结构大概定位到哪部分，然后挨个使用这种方法打印输出，观察输出节点的维度来判断是否为你需要的输出节点）</li>
</ol>
<pre><code>    cout &lt;&lt; &quot;output.c: &quot; &lt;&lt; output.c &lt;&lt; endl;
    cout &lt;&lt; &quot;output.w: &quot; &lt;&lt; output.w &lt;&lt; endl;
    cout &lt;&lt; &quot;output.h: &quot; &lt;&lt; output.h &lt;&lt; endl;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[win10使用RabbitMQ实现消息队列]]></title>
        <id>https://zxpzhong.github.io/post/win10-shi-yong-rabbitmq-shi-xian-xiao-xi-dui-lie</id>
        <link href="https://zxpzhong.github.io/post/win10-shi-yong-rabbitmq-shi-xian-xiao-xi-dui-lie">
        </link>
        <updated>2019-06-19T15:05:16.000Z</updated>
        <summary type="html"><![CDATA[<p>熟悉了linux下使用消息队列实现进程异步，转到win10下该怎么办？</p>
]]></summary>
        <content type="html"><![CDATA[<p>熟悉了linux下使用消息队列实现进程异步，转到win10下该怎么办？</p>
<!-- more -->
<h1 id="第三方消息队列服务rabbitmq">第三方消息队列服务RabbitMQ</h1>
<h2 id="rabbitmq简介">RabbitMQ简介</h2>
<ol>
<li>可靠性（Reliability）:RabbitMQ 使用一些机制来保证可靠性，如持久化、传输确认、发布确认。</li>
<li>灵活的路由（Flexible Routing）:在消息进入队列之前，通过 Exchange 来路由消息的。对于典型的路由功能，RabbitMQ 已经提供了一些内置的 Exchange 来实现。针对更复杂的路由功能，可以将多个 Exchange 绑定在一起，也通过插件机制实现自己的 Exchange 。</li>
<li>消息集群（Clustering）:多个 RabbitMQ 服务器可以组成一个集群，形成一个逻辑 Broker 。</li>
<li>高可用（Highly Available Queues）:队列可以在集群中的机器上进行镜像，使得在部分节点出问题的情况下队列仍然可用。</li>
<li>多种协议（Multi-protocol）:RabbitMQ 支持多种消息队列协议，比如 STOMP、MQTT 等等。</li>
<li>多语言客户端（Many Clients）:RabbitMQ 几乎支持所有常用语言，比如 Java、.NET、Ruby 等等。</li>
<li>管理界面（Management UI）:RabbitMQ 提供了一个易用的用户界面，使得用户可以监控和管理消息 Broker 的许多方面。</li>
<li>跟踪机制（Tracing）:如果消息异常，RabbitMQ 提供了消息跟踪机制，使用者可以找出发生了什么。</li>
<li>插件机制（Plugin System）:RabbitMQ 提供了许多插件，来从多方面进行扩展，也可以编写自己的插件。</li>
</ol>
<h2 id="rabbitmq-server安装">RabbitMQ  server安装</h2>
<ol>
<li>RabbitMQ服务端代码是使用并发式语言Erlang，所以先安装Erlang
<ul>
<li>Erlang官网<a href="http://www.erlang.org/downloads">http://www.erlang.org/downloads</a>，下载对应版本后，安装<br>
<img src="https://s2.ax1x.com/2019/07/30/eGDgqU.png" alt="mark" loading="lazy"></li>
<li>安装位置任意，安装过程中会自动把安装位置的bin目录加入PATH环境变量</li>
</ul>
</li>
<li>官网<a href="http://www.rabbitmq.com/">http://www.rabbitmq.com/</a>，下载对应的安装文件exe，安装<br>
<img src="https://s2.ax1x.com/2019/07/30/eGBw1x.png" alt="mark" loading="lazy"></li>
<li>进入安装目录的sbin目录<br>
<img src="https://s2.ax1x.com/2019/07/30/eGB0c6.png" alt="mark" loading="lazy"></li>
<li>输入<code>rabbitmq-plugins enable rabbitmq_management</code>安装rabbitmq对应的web管理界面</li>
<li>rabbitmq安装后会在操作系统中注册为系统服务，并且自动启动。在浏览器中输入<a href="http://127.0.0.1:15672">http://127.0.0.1:15672</a>,如果正确显示rabbitmq的web界面，则安装正确<br>
<img src="https://s2.ax1x.com/2019/07/30/eGBBjK.png" alt="mark" loading="lazy"></li>
</ol>
<h2 id="rabbitmq-c安装">RabbitMQ-c安装</h2>
<ol>
<li>环境：
<ul>
<li>PC：win10 64位</li>
<li>VS版本：VS2015 msvc14 64bit编译器</li>
<li>RabbitMQ-c版本：v0.9.0</li>
</ul>
</li>
<li>拉取RabbitMQ-c源码：<code>git clone https://github.com/alanxz/rabbitmq-c.git</code></li>
<li>进入RabbitMQ-c目录<code>cd $RabbitMQ-c_PATH/</code>，创建build文件夹<code>mkdir build</code></li>
<li>打开cmake-gui，设置src与build目录为<code>$RabbitMQ-c_PATH/</code>和<code>$RabbitMQ-c_PATH/build</code></li>
<li>编译器选择msvc2014 64bit，如果没有弹出让你选择编译器，则可以点击file-&gt;delete cache来删除缓存，重新选择编译器<br>
<img src="https://s2.ax1x.com/2019/07/30/eGBrnO.png" alt="mark" loading="lazy"></li>
<li>取消勾选ENABLE_SSL_SUPPORT,依次按下configure-&gt;generate-&gt;open project，在VS2015中打开项目<br>
<img src="https://s2.ax1x.com/2019/07/30/eGByHe.png" alt="mark" loading="lazy"></li>
<li>VS中设置64bit release版本<br>
<img src="https://s2.ax1x.com/2019/07/30/eGBgNd.png" alt="mark" loading="lazy"></li>
<li>生成解决方案<br>
<img src="https://s2.ax1x.com/2019/07/30/eGDEgx.png" alt="mark" loading="lazy"></li>
<li>在对应目录下生成库文件<br>
<img src="https://s2.ax1x.com/2019/07/30/eGDNqS.png" alt="mark" loading="lazy"></li>
</ol>
<h2 id="rabbitmq-c封装库simpleamqpclient安装">RabbitMQ-c封装库SimpleAmqpClient安装</h2>
<ol>
<li>安装boost
<ul>
<li><strong>注意，一定要安装二进制安装文件，不要下载源码自己编译</strong>,自己编译可能出现很多问题</li>
<li>下载地址<a href="https://sourceforge.net/projects/boost/files/boost-binaries/">https://sourceforge.net/projects/boost/files/boost-binaries/</a></li>
<li>安装后，include路径为<img src="https://s2.ax1x.com/2019/07/30/eGDdaQ.png" alt="mark" loading="lazy">，lib路径为<img src="https://s2.ax1x.com/2019/07/30/eGDw5j.png" alt="mark" loading="lazy"></li>
</ul>
</li>
<li>安装doxygen（这一步是为了生成API Document，可以不做）
<ul>
<li>下载地址<a href="http://www.doxygen.nl/download.html">http://www.doxygen.nl/download.html</a></li>
<li><img src="https://s2.ax1x.com/2019/07/30/eGDBPs.png" alt="mark" loading="lazy">直接下载对应的安装文件，安装后会自动加入PATH环境变量</li>
</ul>
</li>
<li>git拉取SimpleAmqpClient源码,在SimpleAmqpClient源码下创建build目录</li>
<li>cmake设置src目录和build目录</li>
<li>取消ENABLE_SSL_SUPPORT，手动添加Boost_USE_STATIC_LIBS二进制类型<br>
<img src="https://s2.ax1x.com/2019/07/30/eGDDGn.png" alt="mark" loading="lazy"></li>
<li>手动添加BOOST_ROOT，填入BOOST的安装根目录；手动添加BOOST_LIBRARY，填入BOOST库目录</li>
<li>手动添加Rabbitmqc_INCLUDE_DIR,填入Rabbitmqc的头文件路径，手动添加Rabbitmqc_LIBRARY,填入Rabbitmqc的库路径</li>
<li>取消勾选ENABLE_SSL_SUPPORT,依次按下configure-&gt;generate-&gt;open project，在VS2015中打开项目</li>
<li>VS中设置64bit release版本</li>
<li>在项目属性中添加Rabbitmqc的头文件路径、boost头文件路径，Rabbitmqc的库路径、boost库路径，和对应的lib名称</li>
<li>右键点击项目中的SimpleAmqpClient，点击重新生成，编译成功后，会在build/release目录下生成对应的库<br>
<img src="https://s2.ax1x.com/2019/07/30/eGDsx0.png" alt="mark" loading="lazy"></li>
</ol>
<h2 id="simpleamqpclient-demo测试">SimpleAmqpClient   Demo测试</h2>
<ul>
<li>VS中新建项目</li>
<li>添加<strong>Rabbitmqc</strong>的头文件和库文件；添加<strong>boost</strong>的头文件和库文件；添加<strong>SimpleAmqpClient</strong>的头文件和库文件（怎么添加不详述了）</li>
<li>分别编译下列两个程序，执行后，可以在Send.cpp对应的console中输入任意字符，回车，在Recv.cpp对应的console中可以接收到输入，同时在Rabbitmq的web管理界面可以看到有两个连接接入，并且消息队列的数据流情况都可以看到</li>
</ul>
<p>Send.cpp</p>
<pre><code>#include &lt;SimpleAmqpClient/SimpleAmqpClient.h&gt;
#include &lt;iostream&gt;
int main() {
  std::string queue_name = &quot;hello&quot;;

  AmqpClient::Channel::ptr_t channel = AmqpClient::Channel::Create(&quot;localhost&quot;);
  //创建channel

  channel-&gt;DeclareQueue(queue_name, false, true, false, false);
  //创建队列，第一个参数为队列名称，其余后续会提到。

  std::string message;
  std::cin &gt;&gt; message;

  channel-&gt;BasicPublish(&quot;&quot;, queue_name,
                        AmqpClient::BasicMessage::Create(message));
  //第一个是exchange名称，第二个参数是routing_key（此处可理解为消息会被送往的队列）。

  qDebug() &lt;&lt; &quot;[x] send &quot; &lt;&lt; QString::fromStdString(message);
}
</code></pre>
<p>Recv.cpp</p>
<pre><code>#include &lt;SimpleAmqpClient/SimpleAmqpClient.h&gt;
#include &lt;iostream&gt;

int main() {
  std::string queue_name = &quot;hello&quot;;

  AmqpClient::Channel::ptr_t channel = AmqpClient::Channel::Create(&quot;localhost&quot;);

  channel-&gt;DeclareQueue(queue_name, false, true, false, false);

  std::string consumer_tag = channel-&gt;BasicConsume(queue_name, &quot;&quot;);
  //第二个参数为消费者名称，返回值也是消费者名称。

  while (1) {

    qDebug() &lt;&lt; &quot;[y] receve &quot; &lt;&lt; QString::fromStdString(buffer);

    AmqpClient::Envelope::ptr_t envelope =
        channel-&gt;BasicConsumeMessage(consumer_tag);

    std::string buffer = envelope-&gt;Message()-&gt;Body();
    //消息放在信封里，需要解析

    std::cout &lt;&lt; &quot;[y] receve &quot; &lt;&lt; buffer &lt;&lt; std::endl;
  }

  channel-&gt;BasicCancel(consumer_tag);
  //关闭消费者。
}
</code></pre>
<h1 id="参考博文">参考博文</h1>
<ul>
<li><a href="https://blog.csdn.net/lixiang987654321/article/details/81155299">https://blog.csdn.net/lixiang987654321/article/details/81155299</a></li>
<li><a href="https://blog.csdn.net/weixin_39735923/article/details/79288578">https://blog.csdn.net/weixin_39735923/article/details/79288578</a></li>
<li><a href="https://www.zhihu.com/question/20428371">https://www.zhihu.com/question/20428371</a></li>
<li><a href="https://blog.csdn.net/csm201314/article/category/7023771">https://blog.csdn.net/csm201314/article/category/7023771</a></li>
<li><a href="https://www.jianshu.com/p/79ca08116d57">https://www.jianshu.com/p/79ca08116d57</a></li>
</ul>
<h1 id="踩坑记录">踩坑记录</h1>
<ol>
<li>VS生成库时，提示找不到定义接入点，这是因为没有main函数，不是生成exe而是生成库<a href="https://blog.csdn.net/wushao126/article/details/51785505">https://blog.csdn.net/wushao126/article/details/51785505</a></li>
<li>在win10上编译第三方库时，可以采用CMake配置生成sln对应的文件，然后用VS打开sln进行编译</li>
<li>opencv3.0 &quot;ACCESS_MASK&quot; ambiguous symbol<a href="https://blog.csdn.net/xu20082100226/article/details/45482387">https://blog.csdn.net/xu20082100226/article/details/45482387</a></li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[win10下VS+QT混合编程]]></title>
        <id>https://zxpzhong.github.io/post/win10-xia-vsqt-hun-he-bian-cheng</id>
        <link href="https://zxpzhong.github.io/post/win10-xia-vsqt-hun-he-bian-cheng">
        </link>
        <updated>2019-06-19T15:01:04.000Z</updated>
        <summary type="html"><![CDATA[<p>厌倦了windows系统API？但是又没脱离VS进行环境配置？何不试试windows下的VS+QT混合编程</p>
]]></summary>
        <content type="html"><![CDATA[<p>厌倦了windows系统API？但是又没脱离VS进行环境配置？何不试试windows下的VS+QT混合编程</p>
<!-- more --> 
<h1 id="visiual-studio与qt对比">Visiual Studio与QT对比</h1>
<h2 id="win10下vs进行c编程的痛点">Win10下VS进行c++编程的痛点</h2>
<ul>
<li>功能没有整合，变量名、类名都贼长（是见名知义了，但是每次看都要半天，而且这么长的变名字导致程序密集，看的眼疼）</li>
<li>总是需要大段大段复制粘贴（为什么不把一大段功能整合？）</li>
<li>MFC界面功能完善但是外观老套布局难（相比之下QtCreator就好很多，这也是QtCreator+QT类库用来做界面程序最大的优势了）</li>
</ul>
<h2 id="qt的优点">QT的优点</h2>
<ul>
<li>功能集成度高、功能分类明确、编程时逻辑清晰</li>
<li>跨平台，在linux和win下基本不用考虑操作系统差异</li>
</ul>
<h2 id="qt的缺点">QT的缺点</h2>
<ul>
<li>环境配置远远不如Visual Studio，QtCreator配置环境全部放到.pro文件中，默认使用qmake配置工程，而不是cmake，原意应该是想更加简化cmake适应qt的环境，但是明明在qmake配置过（不论是头文件还是库文件），但是重新构建就是不管用，无解</li>
<li>编译时，常常出现symbol not found错误，一个简单的程序，又没有用到自己外部的库，却老是出现这种莫名其妙的错误</li>
<li>我的熟练的Ctrl+Z技能应该就是大二那会用QT练起来的，明明只是简单的加了几个回车，编译后缺出现symbol not found错误，赶紧回退回退，有时候万一不小心存盘了又找不到旧版，出现symbol not found后然后就完全没办法让程序通过编译，然后又要新建工程，然后把文件都拷贝过来，改来改去</li>
</ul>
<h1 id="vsqt取长补短">VS+QT取长补短</h1>
<p>上面说到了，VS在win下做c++开发天下无敌的有点就是完全可视化的环境配置，所有的头文件、库等等配置全部通过工程的属性中可以设置，相比于Qt Creator为了满足跨平台的需求，必须通过qmake文件（cmake也一样）配置，这种手动输入的方法，对于非常熟练、经验十足的大佬来说没有问题，但是对于一般人来说，要了解所有的qmake中特殊变量名比直接鼠标点点难得多，而且在windows下运行的程序，依赖的环境变量、还有很多我也不知道的东西，感觉比linux下多很多，如果全部都通过手敲代码的形式配置，又麻烦又难记。<br>
所以<strong>综合这两者的优缺点</strong>，采用VS作为IDE用来配置工程依赖+QT类库进行开发，这种方法可行，很大程度上是自称宇宙第一无敌IDE Visual Stidio的功劳，完美得QT插件使得Qt、QtCreator等都可以完美集成到VS中来做（人家QT并不想鸟你而你却强行把人家包含进来干什么！），事实正面，VS在这方面做的确实很好，试了下，基本上不费事，可以完美在VS中开发QT，而且再也不用管qmake文件得编辑了</p>
<h1 id="vsqt安装">VS+QT安装</h1>
<h2 id="qt安装">QT安装</h2>
<ul>
<li>qt版本：5.9.3</li>
<li>下载地址：http://download.qt.io/archive/qt/5.9/5.9.3/</li>
<li>安装注意事项，编译器一定要选择msvc2015-64bit选项，其他可以都不用选择（msvc是win下专用的c++编译器，微软出品；工业相机的SDK程序出厂测试编译器是msvc；VS对msvc的支持性最好）</li>
</ul>
<h2 id="vs安装">VS安装</h2>
<ul>
<li>VS版本：2015 专业版</li>
<li>下载地址：http://download.microsoft.com/download/B/8/9/B898E46E-CBAE-4045-A8E2-2D33DD36F3C4/vs2015.pro_chs.iso</li>
<li>该版本是官方的专业版，不用担心中毒什么的，激活密钥：HMGNV-WCYXV-X7G9W-YCX63-B98R2</li>
<li>安装过程中，选择编译器为msvc2015-x64、msvc2015-x86、MFC支持（以防万一要用）</li>
</ul>
<h2 id="qt与vs完美融合">QT与VS完美融合</h2>
<p>教程地址：<a href="https://blog.csdn.net/yzy_1996/article/details/81939610">https://blog.csdn.net/yzy_1996/article/details/81939610</a></p>
<h2 id="opencv安装">OPENCV安装</h2>
<ul>
<li>opencv版本：3.2</li>
<li>下载地址：https://sourceforge.net/projects/opencvlibrary/files/opencv-win/3.2.0/opencv-3.2.0-vc14.exe/download</li>
<li>不需要安装网上的编译，直接下载opencv win的编译好的包，直接解压后</li>
<li>lib路径：$OPENCV_DIR/build/x64/vc14/lib/opencv_world320.lib</li>
<li>include路径：$OPENCV_DIR/build/include/</li>
</ul>
<h2 id="大恒相机sdk安装">大恒相机SDK安装</h2>
<ul>
<li>版本：V18.06.25.01</li>
<li>下载地址：http://gb.daheng-imaging.com/CN/Software/Cameras/Windows/Galaxy_V18.06.25.01_X86_Win_cn.zip</li>
<li>lib路径：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mi>D</mi><msub><mi>K</mi><mi>D</mi></msub><mi>I</mi><mi>R</mi><mi mathvariant="normal">/</mi><mi>S</mi><mi>a</mi><mi>m</mi><mi>p</mi><mi>l</mi><mi>e</mi><mi>s</mi><mi mathvariant="normal">/</mi><mi>C</mi><mo>+</mo><mo>+</mo><mi>S</mi><mi>D</mi><mi>K</mi><mi mathvariant="normal">/</mi><mi>l</mi><mi>i</mi><mi>b</mi><mi mathvariant="normal">/</mi><mi>x</mi><mn>64</mn><mi mathvariant="normal">/</mi><mo separator="true">;</mo></mrow><annotation encoding="application/x-tex">SDK_DIR/Samples/C++ SDK/lib/x64/;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">D</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">a</span><span class="mord mathdefault">m</span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">+</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">i</span><span class="mord mathdefault">b</span><span class="mord">/</span><span class="mord mathdefault">x</span><span class="mord">6</span><span class="mord">4</span><span class="mord">/</span><span class="mpunct">;</span></span></span></span>SDK_DIR/Samples/VC SDK/lib/x64/;</li>
<li>include路径：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mi>D</mi><msub><mi>K</mi><mi>D</mi></msub><mi>I</mi><mi>R</mi><mi mathvariant="normal">/</mi><mi>S</mi><mi>a</mi><mi>m</mi><mi>p</mi><mi>l</mi><mi>e</mi><mi>s</mi><mi mathvariant="normal">/</mi><mi>C</mi><mo>+</mo><mo>+</mo><mi>S</mi><mi>D</mi><mi>K</mi><mi mathvariant="normal">/</mi><mi>i</mi><mi>n</mi><mi>c</mi><mi mathvariant="normal">/</mi><mo separator="true">;</mo></mrow><annotation encoding="application/x-tex">SDK_DIR/Samples/C++ SDK/inc/;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">D</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">a</span><span class="mord mathdefault">m</span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">+</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mord">/</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">c</span><span class="mord">/</span><span class="mpunct">;</span></span></span></span>SDK_DIR/Samples/VC SDK/inc/;</li>
</ul>
<h1 id="采坑记录">采坑记录</h1>
<h2 id="无法解析的外部符号-winmain">无法解析的外部符号 WinMain</h2>
<p>这是因为windows应用程序分为两种，一种是console（控制台），另一种是windwos（窗口），QT相对于VS的分类属于console，需要将项目/属性/链接器/子系统一栏设置为：(/SUBSYSTEM:CONSOLE)，如果设置为(/SUBSYSTEM:WINDOWS)则会找不到WinMain符号</p>
<h2 id="stdafxh-not-found">stdafx.h not found</h2>
<p>将程序中的这一句话注释，然后将项目/属性/c/c++/预编译头/预编译头一栏修改为不使用预编译头</p>
<h2 id="include-qlabel-qlabel-not-found">#include &quot;QLabel&quot; QLabel not found</h2>
<p>这是因为Qt5.9.3中，将QT加入VS后，默认只添加了<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;EOF&#039;, got &#039;#&#039; at position 78: …gets路径下，因此要改为使用#̲include &quot;QtWidg…'>QT_DIR/msvc2015_64/include/为include路径，但是QLabel文件再include/QtWidgets路径下，因此要改为使用#include &quot;QtWidgets/QLabel&quot;，或者手动将</span>QT_DIR/msvc2015_64/include/QtWidgets添加到include路径中</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[pytorch模型转ncnn]]></title>
        <id>https://zxpzhong.github.io/post/pytorch-mo-xing-zhuan-ncnn</id>
        <link href="https://zxpzhong.github.io/post/pytorch-mo-xing-zhuan-ncnn">
        </link>
        <updated>2019-06-19T14:57:26.000Z</updated>
        <summary type="html"><![CDATA[<p>pytorch模型转ncnn，加速模型运算，在底层运行</p>
]]></summary>
        <content type="html"><![CDATA[<p>pytorch模型转ncnn，加速模型运算，在底层运行</p>
<!-- more -->
<h1 id="pytorch模型转ncnn">pytorch模型转ncnn</h1>
<ul>
<li>ncnn是腾讯公司发布的一款深度学习框架，ncnn 是一个为手机端极致优化的高性能神经网络前向计算框架。</li>
<li>虽然ncnn对于底层CPU运算加速十分明显，尤其是ARM内核的处理器，但是对于大部分深度学习任务来说，使用python+深度学习框架来进行深度模型探索、训练时间性价比更高。</li>
<li>但是最终将模型转到移动端计算时，还是要考虑到移动端的算力，可以从轻量化模型（MobileNet、ShuffleNet等）、权值量化、并行计算、GPU加速、计算框架等去考虑移动端加速</li>
<li>使用pytorch训练模型，再将模型转换为ncnn</li>
</ul>
<hr>
<h1 id="转换的几个思路">转换的几个思路</h1>
<h2 id="pytorch转onnx转ncnn">pytorch转onnx转ncnn</h2>
<p>第一种方式最容易想到，onnx全称Open Neural Network Exchange，本身设计的目的就是用来进行模型之间的相互转换，但是目前不支持ncnn转换。github地址：<a href="https://github.com/onnx/onnx">https://github.com/onnx/onnx</a><br>
<img src="https://s2.ax1x.com/2019/07/30/eG0NSP.png" alt="mark" loading="lazy"></p>
<h2 id="pytorch转caffe转ncnn">pytorch转caffe转ncnn</h2>
<p>ncnn官方似乎对caffe模型情有独钟，师兄在找我要模型的时候，都是直接说要caffe模型而不是ncnn模型，由此可见caffe与ncnn的亲密程度了，不过这也极有可能是因为caffe模型在移动端的优化做的也比较好。<br>
其他pytorch转caffe工具，比如pytorch2caffe，github地址：<a href="https://github.com/longcw/pytorch2caffe">https://github.com/longcw/pytorch2caffe</a>，但是实际测试后感觉效果不理想</p>
<h2 id="pytorch直接转ncnn">pytorch直接转ncnn</h2>
<p>ncnn官方的源码中，pytorch转ncnn的推荐方法是使用PytorchConverter github地址：<a href="https://github.com/starimeL/PytorchConverter">https://github.com/starimeL/PytorchConverter</a>，经过多种方案测试无数次次后验证该方法可行<br>
<img src="https://s2.ax1x.com/2019/07/30/eG0UQf.png" alt="mark" loading="lazy"></p>
<h1 id="pytorchconverter将pytorch转换为ncnn过程">PytorchConverter将Pytorch转换为ncnn过程</h1>
<h2 id="版本要求训练和转换时都必须满足这个版本要求">版本要求(训练和转换时都必须满足这个版本要求)</h2>
<ul>
<li>pytorch : torch==0.2</li>
<li>torchvision==0.1.8</li>
</ul>
<h2 id="转换过程">转换过程</h2>
<ol>
<li>将PytorchConverter源码通过git克隆到本地</li>
<li>打开run.py，可以看到其代码中内置了ResNet、MobileNet等，通过模仿其转换MobileNet的过程，可以写出自己的转换代码</li>
<li>运行run.py将自己的pytorch模型转换为ncnn模型</li>
</ol>
<h2 id="踩坑记录">踩坑记录</h2>
<ol>
<li>pytorch版本不要太高，否则生成的模型的层名和ncnn转换时无法对应上，导致转换出错</li>
<li>nn.logsoftmax()函数不支持，~~因此将NLL LOSS+logsoftmax转用CrossEntropy+softmax。~~参考：<a href="https://blog.csdn.net/hao5335156/article/details/80607732">https://blog.csdn.net/hao5335156/article/details/80607732</a>。再次验证后，发现能够得到正常结果的是NLL + logsoftmax，虽然在模型转换时，logsoftmax不支持，但是由于logsoftmax只在训练时起作用，<strong>所以可以在训练测试正常使用Logsoftmax，在模型转换时再换为softmax</strong>，因为softmax没有参数，所以原来保存的参数仍然你可以正常加载，且不影响最终<strong>特征层</strong>的输出。</li>
<li>pytorch的pooling函数对奇数特征图长宽处理时，会将最外一层去掉，强制将特征图转换为偶数；而ncnn在处理时，会将奇数长宽强制+1后再处理。如果不注意这个问题，会导致最终进入全连接层时矩阵维度不对导致无法相乘，在ncnn c++模型测试代码中会出现其他层都有输出，但是一到全连接层时，程序直接崩溃。解决办法是在pooling函数的参数列表中加入 <code>ceil_mode=True</code>。参考：<a href="https://github.com/pytorch/pytorch/issues/6842#issuecomment-383332045">https://github.com/pytorch/pytorch/issues/6842#issuecomment-383332045</a><br>
<img src="https://s2.ax1x.com/2019/07/30/eG0yYn.png" alt="mark" loading="lazy"></li>
<li>pytorch中的ReLU6激活函数PytorchConverter不支持转换，可以改用RuLU或者LeakyReLU</li>
<li>PytorchConverter工具对python版本貌似没有要求，我测试过python2.7和3.6版本都可以正常使用，但是torch和torchvision的版本必须控制</li>
<li>还是推荐使用python3.x版本，python2.7中整数除以整数<strong>只会整除</strong>，本人被这个问题卡了一整个上午；而python3中整数除以整数自动得到小数（不得不说太贴心了~）</li>
<li>torch==0.2中，softmax和logsoftmax函数都不支持dim参数，直接去掉即可，因为最终到全连接层这儿的时候，只有一个维度了，所以做softmax的时候，也只有一个维度可以使用</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Github做图床]]></title>
        <id>https://zxpzhong.github.io/post/github-zuo-tu-chuang</id>
        <link href="https://zxpzhong.github.io/post/github-zuo-tu-chuang">
        </link>
        <updated>2019-06-19T14:54:34.000Z</updated>
        <content type="html"><![CDATA[<h1 id="markdown相比于word-txt文本的优缺点">MarkDown相比于word txt文本的优缺点</h1>
<p>在写个人记录、个人博客时，MarkDown是一种比较好的选择</p>
<ul>
<li>相比于work文档，MD编辑起来更加轻量化，占用系统资源小，不容易卡死。当你工作的时候，电脑打开大量的软件，这时如果你想编辑一一个word文档，打开word后，呕吼，完蛋，电脑卡死了或者word卡死了，虽然说word卡死一般也不会导致文件内容丢失，但是让你卡几分钟也是很难受的</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://s2.ax1x.com/2019/07/30/eG0kdJ.png" alt="" loading="lazy"></figure>
<ul>
<li>相比于纯txt文档，其编辑时候的方式都是一样，使用纯键盘输入即可，但是加入MarkDown特有的标识符，MD文档可以渲染成一个带有格式的可展示文档，输入的难度不增加，且可展示性大大提高，不仅可以作为自己的个人记录，还可以直接发在CSDN、GITPAGE上，而且越来越多的博客系统也开始支持MarkDown语法了<br>
<img src="https://s2.ax1x.com/2019/07/30/eG0ZJ1.png" alt="" loading="lazy"></li>
</ul>
<h1 id="markdown基本语法">MarkDown基本语法</h1>
<p>这里就不赘述了，直接出门左转谷歌即可</p>
<p><a href="https://www.jianshu.com/p/191d1e21f7ed">https://www.jianshu.com/p/191d1e21f7ed</a></p>
<h1 id="markdown中的图片链接">MarkDown中的图片链接</h1>
<ul>
<li>在MarkDown中可以很快速得表示标题级数、有序无序列表、链接、代码段等等，最让人头痛的应该就是图片了，因为图片无法直接作为MD文本源码的一部分插入，只能插入图片的地址，这个地址可以是相对MD文件的相对路径，也可以是网络图片地址</li>
<li><strong>如果将图片作为MD的相对路径插入MD文件中</strong>，在移动文件时，需要将图片与MD保持相对路径不变一起移动（比较好的办法是压缩打包后一起移动），否则极有可能出现访问图片无法正常加载</li>
<li>为了能够将MD文件作为一个独立的文件移动，且其中的图片不丢失，比较好的一个解决办法是将网络图片地址插入MD文档中，这种办法虽然依赖于网络，但是连个网对于9102年应该不是什么难事吧~</li>
</ul>
<h1 id="如何将图片保存在网络上且获得图片的直链地址">如何将图片保存在网络上且获得图片的直链地址</h1>
<p>这里直接把各类网盘（百度云、GDrive、OneDrive等等）排除在外了，因为网盘虽然上传图片比较方便，但是网盘中的图片无法获取到直链，或者获取到直链后很快就无法使用了</p>
<h2 id="自建图片服务器">自建图片服务器</h2>
<p>自建图片服务器的话，可以使用ftp、nginx、开源图床、网盘程序等等，但是费用较贵，而且你会忍不住去维护，最后不仅仅浪费了钱，还浪费了生命，血亏!</p>
<h2 id="云储存对象">云储存对象</h2>
<p>腾讯云、阿里云、等等云都提供云储存对象，虽然前几个月有免费额度，但是后面还是要收费滴，而且储存要收费、上传流量要收费、下载流量要收费、CDN回源要收费，请问看了这么多收费项后，谁还敢用啊~~~~其次还有七牛云、又拍云等有免费的储存空间，流量每个月也有免费，是一个不错的选择</p>
<h2 id="第三方图床">第三方图床</h2>
<p>感觉比较好用的有：</p>
<ul>
<li><a href="https://sm.ms/">https://sm.ms/</a></li>
<li><a href="https://imgchr.com/">https://imgchr.com/</a></li>
<li>第三方图床速度快，储存限制也比较小，比如每小时上传20张，每张大小小于10M之类的，对于写MD远远够了，主要是怕服务商跑路，跑路后图片消失没有了，除非你付费</li>
</ul>
<h2 id="github-repo图床">Github repo图床</h2>
<p>Github的repo也可以储存东西，最直接的就是程序的版本控制，当然也可以用来当作备份储存，用来储存图片（github官方回复是：该行为不构成abuse，如果把github当图床算滥用，那么那么多人把微博当图床怎么就理所应当捏）。其实github对于国内的响应速度并不快，而且时不时被block，所以用github当图床完全是出于储存个人用途的自创图片，并不能当CDN使用。github自从被微软收购后，我对github的信心大增，代码以前只敢用git管理保存在本地，现在可以放心大胆上传到github了（很多是private，所以不可见），github图床主要就是图个稳定，也并不是想恶意刷github服务器的流量，恶意影响大家的体验。</p>
<ol>
<li>
<p>新建repo，名称任意</p>
</li>
<li>
<p>打开账户/Settings/Developer settings/Personal access tokens,点击Generate new token<br>
<img src="https://s2.ax1x.com/2019/07/30/eG0uQK.png" alt="" loading="lazy"><br>
<img src="https://s2.ax1x.com/2019/07/30/eG0KsO.png" alt="" loading="lazy"></p>
</li>
<li>
<p>在弹出的产生token页面，Token description随意填写，但是一定要勾选上这几项<br>
<img src="https://raw.githubusercontent.com/zxpzhong/image/master/imgs/20190227201200.png" alt="" loading="lazy"></p>
</li>
<li>
<p>下载PicGo客户端对应的版本并安装，github地址：<a href="https://github.com/Molunerfinn/PicGo/releases">https://github.com/Molunerfinn/PicGo/releases</a></p>
</li>
<li>
<p>启动PicGo后，打开设置界面，点击<br>
<img src="https://s2.ax1x.com/2019/07/30/eG0lee.png" alt="" loading="lazy"><br>
在第一栏填入你的github名称/repo名称；在第二栏填入你的分支名称，默认为master；在第三栏填入你刚才申请到的Token；第四栏填入你的repo中的储存路径；最后点击确认，再点击设为默认图床</p>
</li>
<li>
<p>使用QQ截图Ctrl+Alt+A或者微信的Alt+A截图后，按下Ctrl+Shiht+P快捷键即可自动上传到github对应的repo中，上传完成后，会有提示，自动将对应的图片地址送入剪贴板中，直接Ctrl+V即可粘贴对应的地址出来了~~</p>
</li>
</ol>
<h2 id="picgo中使用其他图床">PicGo中使用其他图床</h2>
<p>PicGo一共支持多种图床：<br>
<img src="https://s2.ax1x.com/2019/07/30/eG03od.png" alt="" loading="lazy"></p>
<ul>
<li>其中SM.MS图床是免费且不需要账号的图床，缺点是无法查看历史上传的图片，因此每次使用同一张图片都需要重新上传一张一样的获取新的地址，或者是拷贝之前上传过的地址</li>
<li><s>微博图床，我设置好账号和密码后，并不能正常上传，原因应该是微博限制了必须加上验证码才能登陆，所以微博图床对于这款程序并不太友好，应该说微博图床上传图片都很麻烦，登录过程就很麻烦，如果手动上传，感觉更麻烦，所以还是不推荐用微博图床</s>      经过再次测试后，发现<strong>微博第一次在某台电脑上登陆</strong>时，验证比较复杂，需要输入验证码，还有可能需要验证手机号，所以可以使用浏览器在网页中打开微博，然后登陆自己的微博，登陆成功后，在使用PicGo选择微博图床，进行上传测试，这时就可以正常上传了<img src="https://ws1.sinaimg.cn/large/006hYrYngy1g0nhxp4k10j305v05q40e.jpg" alt="" loading="lazy"></li>
<li>腾讯、阿里的对象储存，上面说了，免费都有时间，过了免费时间后，可能需要付费，主要优势就是CDN加速了，超快，当然如果你的博客看的人多了，那么流量也多，费用也贵</li>
<li>七牛云和又拍云可以申请免费储存空间，是不错的选择，但是也要小心流量被刷导致扣费、封号，具体可以看看别人的前车之鉴</li>
</ul>
<hr>
<figure data-type="image" tabindex="2"><img src="https://s2.ax1x.com/2019/07/30/eG0GFA.png" alt="" loading="lazy"></figure>
<ul>
<li>Imgur也是免费的图床，是国外网站，相对国内速度不太理想，还是SM.MS速度快些</li>
</ul>
<h1 id="github图床缺点">Github图床缺点</h1>
<ol>
<li>对应储存图片的repo必须是public，如果是pravite，那么图片地址会带有一个随时刷新token，这样虽然repo他人不可见，但是也没法作为图床用</li>
<li>图床每添加一张，那么会提交一次commit，这样会导致你的github动向表部分一片绿。。。。。虽然这样显得你很活跃，但是真正点进去会发现你的代码更新并没有你真正提交commit的频率高。</li>
</ol>
<h1 id="禁止滥用">禁止滥用</h1>
<p>对于个人MD使用来说，Github是一个相对稳定（微软收购后更加稳定了）、不用付费、可以查看历史、速度还行的图床。但是绝对不适用于大流量的场所，只限于个人小流量使用！！！！！！！！！！！！！！！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Gridea对接github page]]></title>
        <id>https://zxpzhong.github.io/post/gridea-dui-jie-github-page</id>
        <link href="https://zxpzhong.github.io/post/gridea-dui-jie-github-page">
        </link>
        <updated>2019-06-19T12:51:50.000Z</updated>
        <summary type="html"><![CDATA[<p>原来一直使用hexo部署github，但是hexo发布起来麻烦，而且使用体验感觉没有那么好，看到这个Gridea感觉不错，因此试了一下！！</p>
]]></summary>
        <content type="html"><![CDATA[<p>原来一直使用hexo部署github，但是hexo发布起来麻烦，而且使用体验感觉没有那么好，看到这个Gridea感觉不错，因此试了一下！！</p>
<!-- more -->
<h2 id="hexo部署github-page的缺点">hexo部署github page的缺点</h2>
<ol>
<li>hexo主题虽然多但是一般自己只会喜欢一两个，尤其是hexo的自定义程度高，可以用来玩（一玩玩一天的那种- - ！）但是对于我这种对于前端完全是小白的代码搬运工，并不是很想用可玩性这么高的，因为不自己配置没有特色，自己配置又搞不来</li>
<li>hexo文章的属性在MD文件的开头，需要手动设置，Gridea把这几项都集成到了软件中，使用起来比较人性化!<br>
<img src="https://s2.ax1x.com/2019/07/30/eG0FZ4.png" alt="mark" loading="lazy"></li>
<li>编辑界面集成到了Gridea中，编辑发布一体化，适合小白使用</li>
<li>可以把Gridea源位置设置在onedrive文件夹，这样还可以动态备份，就算换电脑，换软件，把文件夹下载下来还可以继续编辑</li>
</ol>
<h2 id="部署流程">部署流程</h2>
<p>具体细节可以搜索github page部署教程，这里只写Gridea软件如何设置</p>
<h3 id="安装gridea">安装Gridea</h3>
<p>从Gridea网站下载软件，然后在下图中，设置好自己的github page域名，仓库名称，用户名（github用户名），邮箱，Token生成方法自行搜索<br>
<img src="https://s2.ax1x.com/2019/07/30/eG0CsU.png" alt="mark" loading="lazy"></p>
<h3 id="gitalk评论系统配置">gitalk评论系统配置</h3>
<p><img src="https://s2.ax1x.com/2019/07/30/eGwzR0.png" alt="mark" loading="lazy"><br>
在自己的github设置页面内-&gt;Developer settings-&gt;OAuth Apps-&gt;new OAuth App,新建一个，然后会返回一个client ID和一个Client Seceret<br>
<img src="https://s2.ax1x.com/2019/07/30/eGw7M8.png" alt="mark" loading="lazy"><br>
将这个client ID和Client Seceret填入Gridea中</p>
<h3 id="其他设置">其他设置</h3>
<p>可以直接可视化设置头像、主题、一些样式、显示内容、标签等，这点是我最喜欢的<br>
<strong>完成设置后，可以发布测试一下，输入你的github page域名，即可看到对应的页面</strong></p>
]]></content>
    </entry>
</feed>